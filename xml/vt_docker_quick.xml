<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<!-- Converted by suse-upgrade version 1.1 -->
<?xml-stylesheet href="urn:x-suse:xslt:profiling:docbook50-profile.xsl" type="text/xml" title="Profiling step"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="art.docker" xml:lang="en">
<?suse-quickstart color="suse"?>
 <title>Docker Quick Start</title>
 <subtitle>&productname; &productnumber;</subtitle>
 <info><productname>&productname;</productname>
  <productnumber>&productnumber;</productnumber><date>
<?dbtimestamp format="B d, Y"?></date>
  <abstract>
   <para>
    This guide introduces Docker, a lightweight virtualization solution to
    run virtual units simultaneously on a single control host.
   </para>
  </abstract>
 </info>
<?suse-quickstart color="suse"?>
 <para>
  Docker is a lightweight virtualization solution to run multiple virtual
  units (containers) simultaneously on a single control host. Containers are
  isolated with Kernel Control Groups (<xref linkend="vle.docker.cgroup"/>)
  and <xref linkend="vle.docker.namespace"/>.
 </para>
 <para>
  Full virtualization solutions such as &xen;, &kvm;, or &libvirt; are based
  on the processor simulating a complete hardware environment and
  controlling the virtual machines. However, Docker only provides operating
  system-level virtualization where the Linux kernel controls isolated
  containers.
 </para>
 <sect1 xml:id="sec.docker.term">
  <title>Terminology</title>

  <para>
   The following list contains important terminology and introduces you to
   certain fundamental concepts of Docker.
   <remark>taroth 2014-10-30: aginies,
    perhaps sort the terms alphabetically? like in a glossary?</remark>
  </para>

  <variablelist>
   <varlistentry xml:id="vle.docker.cgroup">
    <term>cgroups</term>
    <listitem>
     <para>
      Control Groups is a Linux kernel feature that allows aggregating or
      partitioning tasks (processes) and all their children into
      hierarchically organized groups to isolate resources.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Image</term>
    <listitem>
     <para>
      A <emphasis>virtual machine</emphasis> on the host server that can run
      any Linux system, for example &sls;, &sled;, or &opensuse;. A Docker
      image is made by a series of layers built one over the other. Each
      layer corresponds to a permanent change committed from a container to
      the image. For more details, see the official Docker documentation at
      <link xlink:href="http://docs.docker.com/terms/image/"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Image Name</term>
    <listitem>
     <para>
      A name that refers to an image. The name is used by the Docker
      commands.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Container</term>
    <listitem>
     <para>
      A running Docker image.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Container ID</term>
    <listitem>
     <para>
      An ID that refers to a particular container. The ID is used by the
      Docker commands.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Tag</term>
    <listitem>
     <para>
      A string associated with an image. It is commonly used to identify a
      specific version of an image (similar to tags in version control
      systems). It is also possible to refer the same image with different
      tags.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry xml:id="vle.docker.namespace">
    <term>Kernel Namespaces</term>
    <listitem>
     <para>
      Namespaces are a kernel feature to isolate some resources like
      network, users, and others for a group of processes.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Docker Host Server</term>
    <listitem>
     <para>
      The system that runs the Docker daemon, and provides images and
      management control capabilities through
      <xref linkend="vle.docker.cgroup"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Registry</term>
    <listitem>
     <para>
      A remote storage for Docker images.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Repository</term>
    <listitem>
     <para>
      Place where all the version of a Docker image are kept.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="sec.docker.overview">
  <title>Overview</title>

  <para>
   Docker is a platform that allows developers and system administrators to
   manage the complete life cycle of images. Docker makes it easy to build,
   ship and run images containing applications.
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <title>Benefits of Docker</title>
   <listitem>
    <para>
     Isolation of applications and operating systems through containers.
    </para>
   </listitem>
   <listitem>
    <para>
     Near native performance, as Docker manages allocation of resources in
     real-time.
    </para>
   </listitem>
   <listitem>
    <para>
     Controls network interfaces and resources available inside containers
     through cgroups.
    </para>
   </listitem>
   <listitem>
    <para>
     Versioning of images.
    </para>
   </listitem>
   <listitem>
    <para>
     Allows building new images based on existing ones.
    </para>
   </listitem>
   <listitem>
    <para>
     Docker Hub allows sharing and storing of images on
     <link xlink:href="http://docs.docker.com/docker-hub/">public</link> or
     <link xlink:href="http://docs.docker.com/userguide/dockerrepos/#private-repositories">
     private</link> repositories.
    </para>
   </listitem>
  </itemizedlist>

  <itemizedlist mark="bullet" spacing="normal">
   <title>Limitations of Docker</title>
   <listitem>
    <para>
     Containers run inside the host system's kernel and cannot use a
     different kernel.
    </para>
   </listitem>
   <listitem>
    <para>
     Only allows Linux <emphasis>guest</emphasis> operating systems.
    </para>
   </listitem>
   <listitem>
    <para>
     Docker is not a full virtualization stack like &xen;, &kvm;, or
     &libvirt;.
    </para>
   </listitem>
   <listitem>
    <para>
     Security depends on the host system. Refer to the
     <link xlink:href="http://docs.docker.com/articles/security/">official
     security documentation</link> for more details.
    </para>
   </listitem>
  </itemizedlist>

  <sect2 xml:id="sec.docker.containerd">
   <title>Container Drivers</title>
   <para>
    Docker has different back-end drivers to handle containers:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      <link xlink:href="https://github.com/docker/libcontainer">libcontainer</link>:
      this is the recommended driver and the default choice.
     </para>
    </listitem>
    <listitem>
     <para>
      &lxc;: this driver handles the containers using the &lxc; tools.
      &productname; &productnumber; does not provide the &lxc; package,
      hence this driver cannot be used.
     </para>
    </listitem>
    <listitem>
     <para>
      <systemitem class="library">libvirt-lxc</systemitem>: this driver
      controls the containers using the
      <link xlink:href="http://libvirt.org/drvlxc.html">libvirt-lxc</link>
      tool. At the time of writing this driver is not yet mature as the
      others.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="sec.docker.storaged">
   <title>Storage Drivers</title>
   <para>
    Docker supports different storage drivers:
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      <systemitem class="resource">vfs</systemitem>: this driver is
      automatically used when the Docker host file system does not support
      copy-on-write. This is a simple driver which does not offer some of
      the advantages of Docker (like sharing layers, more on that in the
      next sections). It is highly reliable but also slow.
     </para>
    </listitem>
    <listitem>
     <para>
      <systemitem class="resource">devicemapper</systemitem>: this driver
      relies on the device-mapper thin provisioning module. It supports
      copy-on-write, hence it offers all the advantages of Docker.
     </para>
    </listitem>
    <listitem>
     <para>
      <systemitem class="resource">btrfs</systemitem>: this driver relies on
      Btrfs to provide all the features required by Docker. To use this
      driver the <filename>/var/lib/docker</filename> directory must be on a
      Btrfs file system.
     </para>
    </listitem>
    <listitem>
     <para>
      <systemitem class="resource">AUFS</systemitem>: this driver relies on
      AUFS union file system. Neither the upstream kernel nor the SUSE one
      supports this file system. Hence the AUFS driver is not built into the
      SUSE Docker package.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    &slea;&nbsp;12 uses the Btrfs file system by default, which leads Docker
    to use the <systemitem class="resource">btrfs</systemitem> driver.
   </para>
   <para>
    It is possible to specify which driver to use by changing the value of
    the <envar>DOCKER_OPTS</envar> variable defined inside of the
    <filename>/etc/sysconfig/docker</filename> file. This can be done either
    manually or using &yast; by browsing to <menuchoice>
    <guimenu>System</guimenu> <guimenu>/etc/sysconfig Editor</guimenu>
    <guimenu>System</guimenu> <guimenu>Management</guimenu>
    <guimenu>DOCKER_OPTS</guimenu> </menuchoice> menu and entering the
    <systemitem class="library">-s storage_driver</systemitem> string.
   </para>
   <para>
    For example, to force the usage of the
    <systemitem class="resource">devicemapper</systemitem> driver enter the
    following text:
   </para>
<screen>DOCKER_OPTS="-s devicemapper</screen>
   <note>
    <para>
     It is recommended to have <filename>/var/lib/docker</filename> mounted
     on a different file system to not affect the Docker host operating
     system in case of a file system corruption.
    </para>
   </note>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.docker.setup">
  <title>Setting Up a Docker Host</title>

  <para/>

  <sect2 xml:id="sec.docker.setup.general">
   <title>General Preparation</title>
   <para>
    Prepare the host:
   </para>
   <procedure>
    <step>
     <para>
      Install the <systemitem>docker</systemitem> package.
     </para>
    </step>
    <step>
     <para>
      Automatically start the Docker daemon at boot:
     </para>
<screen>sudo systemctl enable docker</screen>
    </step>
    <step>
     <para>
      Start the Docker daemon:
     </para>
<screen>sudo systemctl start docker</screen>
    </step>
   </procedure>
   <para>
    The Docker daemon listens on a local socket which is accessible only by
    the <systemitem class="username">root</systemitem> user and by the
    members of the <systemitem class="groupname">docker</systemitem> group.
    The <systemitem class="groupname">docker</systemitem> group is
    automatically created at package installation time. To allow a certain
    user to connect to the local Docker daemon, use the following command:
   </para>
<screen>sudo /usr/sbin/usermod -aG docker <replaceable>USERNAME</replaceable></screen>
   <para>
    The user can communicate with the local Docker daemon upon his next
    login.
   </para>
  </sect2>

  <sect2 xml:id="sec.docker.setup.net">
   <title>Networking</title>
   <para>
    If you want your containers to be able to access the external network,
    you must enable the <option>ipv4 ip_forward</option> rule. This can be
    done using &yast; by browsing to <menuchoice> <guimenu>Network
    Devices</guimenu> <guimenu>Network Settings</guimenu>
    <guimenu>Routing</guimenu> </menuchoice> menu and ensuring
    <option>Enable IPv4 Forwarding</option> is checked.
   </para>
   <para>
    This option cannot be changed when networking is handled by the Network
    Manager. In such cases the
    <filename>/etc/sysconfig/SuSEfirewall2</filename> file needs to be
    edited by hand to ensure the <option>FW_ROUTE</option> flag is set to
    <option>yes</option>:
   </para>
<screen>FW_ROUTE="yes"</screen>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.docker.basic">
  <title>Basic Docker Operations</title>

  <para>
   Images can be pulled from Docker's central index at
   <link xlink:href="http://index.docker.io"/> using the following command:
  </para>

<screen>docker pull <replaceable>IMAGE_NAME</replaceable></screen>

  <para>
   Containers can be started using the <command>docker run</command>
   command. Refer to the official documentation of Docker at
   <link xlink:href="http://docs.docker.com/"/> for more details.
  </para>
 </sect1>
 <sect1 xml:id="sec.docker.building_images">
  <title>Building Docker Images</title>

  <para>
   Starting with version 5.06.8, &kiwi; can be used to build Docker images.
   Also see the official &kiwi; documentation, in particular
   <link xlink:href="https://doc.opensuse.org/projects/kiwi/doc/#chap.lxc"/>.
   The official <systemitem>kiwi-doc</systemitem> package contains examples
   of Docker images.
  </para>

  <para>
   Docker has an
   <link xlink:href="http://docs.docker.com/reference/builder/">internal
   build system</link> which can be used to create new images based on
   existing ones.
  </para>

  <para>
   Some users might be confused about which build system to use for what
   task. The recommended approach is to build the
   <link xlink:href="http://docs.docker.com/terms/image/#base-image-def">base
   images</link> using &kiwi; and then use those as foundation blocks inside
   of the Docker build system. This approach has two advantages:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     You can use Docker-specific directives (like
     <literal>ENTRYPOINT</literal>, <literal>EXPOSE</literal>, ...).
    </para>
   </listitem>
   <listitem>
    <para>
     You can re-use existing layers.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Sharing the common layers between different images makes it possible to:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     Use less disk space on the Docker hosts and on the remote registry
     service.
    </para>
   </listitem>
   <listitem>
    <para>
     Deploy faster: only the requested layers are sent over the network
     (this is similar to upgrading installed packages using delta RPMs).
    </para>
   </listitem>
   <listitem>
    <para>
     Take full advantage of caching while building Docker images: this will
     result in faster executions of the <command>docker build</command>
     command.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   As you can see, &kiwi; is not intended as a replacement for Docker's
   build system, it rather complements it.
  </para>
 </sect1>
 <sect1 xml:id="sec.docker.sle_images">
  <title>&sle; Images for Docker</title>

  <para>
   Currently we cannot distribute &slea; images for Docker because there is
   no way to associate an End-User License Agreement (EULA) to a Docker
   image. However, we provide official pre-built Docker images for &slea;
   and a convenience tool called
   <link xlink:href="https://github.com/SUSE/sle2docker">sle2docker</link>
   that can be used to activate these images locally.
  </para>

  <para>
   Pre-built images do not have repositories configured. But when the Docker
   host has a SLE subscription that provides access to the product used in
   the image, Zypper will automatically have access to the right
   repositories. For more details see
   <xref
   linkend="sec.docker.sle_images.customizing_the_images"/>.
  </para>

  <sect2 xml:id="sec.docker.sle_images.sle2docker_install">
   <title>Installing sle2docker</title>
   <para>
    The <command>sle2docker</command> tool is part of the official container
    module. It can be installed using the following command:
   </para>
<screen>sudo zypper install sle2docker</screen>
   <note>
    <para>
     <command>sle2docker</command> requires the Docker daemon to be running
     on the system.
    </para>
   </note>
  </sect2>

  <sect2 xml:id="sec.docker.sle_images.activate">
   <title>Activating the Pre-built Docker Images</title>
   <para>
    The official pre-built Docker images for &slea; are shipped as RPM
    packages inside of the <literal>containers</literal> module. They can be
    installed using Zypper:
   </para>
<screen>sudo zypper in sles11sp3-docker-image sles12-docker-image</screen>
   <para>
    <command>sle2docker</command> can list the available pre-built images
    with the following command:
   </para>
<screen>sle2docker list</screen>
   <para>
    To activate a pre-built image, use the following command:
   </para>
<screen>sle2docker activate <replaceable>PRE-BUILT_IMAGE_NAME</replaceable></screen>
   <para>
    At the end of the activation, <command>sle2docker</command> will print
    the name of the Docker image that has been created.
   </para>
  </sect2>

  <sect2 xml:id="sec.docker.sle_images.customizing_the_images">
   <title>Customizing the Images</title>
   <para>
    To create custom Docker images based on the official ones use
    <link xlink:href="http://docs.docker.com/reference/builder/"> Docker's
    integrated build system </link>.
   </para>
   <para>
    The pre-built images do not have any repository configured. They contain
    a <link xlink:href="https://github.com/SUSE/container-suseconnect"> zypper
    service</link> that contacts either the &scc; (SCC) or your
    Subscription Management Tool (&smt;) server, according to the
    configuration of the &slea; host that runs the Docker container. The
    service obtains the list of repositories available for the product used
    by the Docker image.
   </para>
   <para>
    You do not need to add any credentials to the Docker image because the
    machine credentials are automatically injected into the container by the
    docker daemon. They are injected inside of the
    <filename>/run/secrets</filename> directory. The same applies to the
    <filename>/etc/SUSEConnect</filename> file of the host system, which is
    automatically injected into the <filename>/run/secrets</filename> file.
   </para>
   <note>
    <para>
     The contents of the <filename>/run/secrets</filename> directory are
     never committed to a Docker image, hence there's no risk of your
     credentials leaking.
    </para>
   </note>
   <para>
    To obtain the list of repositories use the following command:
   </para>
<screen>zypper ref -s</screen>
   <para>
    It will automatically add all the repositories to your container. For
    each repository added to the system a new file is going to be created
    under <command>/etc/zypp/repos.d</command>. The URLs of these
    repositories include an access token that automatically expires after 12
    hours. To renew the token call the <command>zypper ref -s</command>
    command. It is secure to commit these files to a Docker image.
   </para>
   <para>
    If you want to use a different set of credentials, place a custom
    <filename>/etc/zypp/credentials.d/SCCcredentials</filename> file inside
    of the Docker image. It contains the machine credentials that have the
    subscription you want to use. The same applies to the
    <filename>SUSEConnect</filename> file: to override the file available on
    the host system that is running the Docker container, add a custom
    <filename>/etc/SUSEConnect</filename> file inside of the Docker image.
   </para>
   <sect3 xml:id="sec.docker.sle_images.customizing_the_images.sles12">
    <title>Creating a Custom &slea;&nbsp;12 Image</title>
    <para>
     The following Docker file creates a simple Docker image based on
     &slea;&nbsp;12:
    </para>
<screen>FROM suse/sles12:latest

RUN zypper --gpg-auto-import-keys ref -s
RUN zypper -n in vim</screen>
    <para>
     When the Docker host machine is registered against an internal &smt;
     server, the Docker image requires the SSL certificate used by &smt;:
    </para>
<screen>FROM suse/sles12:latest

        # Import the crt file of our private SMT server
        ADD http://smt.test.lan/smt.crt /etc/pki/trust/anchors/smt.crt
        RUN update-ca-certificates

        RUN zypper --gpg-auto-import-keys ref -s
        RUN zypper -n in vim</screen>
   </sect3>
   <sect3 xml:id="sec.docker.sle_images.customizing_the_images.sles11sp3">
    <title>Creating a Custom &slea;&nbsp;11 SP3 Image</title>
    <para>
     The following Docker file creates a simple Docker image based on
     &slea;&nbsp;11 SP3:
    </para>
<screen>FROM suse/sles11sp3:latest

RUN zypper --gpg-auto-import-keys ref -s
RUN zypper -n in vim</screen>
    <para>
     When the Docker host machine is registered against an internal &smt;
     server, the Docker image requires the SSL certificate used by &smt;:
    </para>
<screen>FROM suse/sles11sp3:latest

# Import the crt file of our private SMT server
ADD http://smt.test.lan/smt.crt /etc/ssl/certs/smt.pem
RUN c_rehash /etc/ssl/certs

RUN zypper --gpg-auto-import-keys ref -s
RUN zypper -n in vim</screen>
   </sect3>
  </sect2>
 </sect1>
</article>
