<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd"
[
<!ENTITY % NOVDOC.DEACTIVATE.IDREF "INCLUDE">
<!ENTITY % entities SYSTEM "entity-decl.ent">
%entities;
]>

<article id="art.docker" lang="en">
 <?suse-quickstart color="suse"?>
 <title>Docker Quick Start Guide</title>
 <articleinfo>
  <productname>&productname;</productname>
  <productnumber>&productnumber;</productnumber>
  <date><?dbtimestamp format="B d, Y"?></date>
 </articleinfo>

 <abstract>
  <para>
   This guide introduces Docker, a lightweight
   virtualization solution to run virtual units
   simultaneously on a single control host.
  </para>
 </abstract>
 <para>
  Docker is a lightweight virtualization solution to run multiple virtual units
  (containers) simultaneously on a single control host.
  Containers are isolated with Kernel Control Groups (<xref
  linkend="vle.docker.cgroup"/>) and <xref linkend="vle.docker.namespace"/>.
 </para>
 <para>
  Full virtualization solutions such as &xen;, &kvm;, or &libvirt; are based on
  the processor simulating a complete hardware environment and controlling the
  virtual machines. However, Docker only provides operating system-level
  virtualization where the Linux kernel controls isolated containers.
 </para>

 <sect1 id="sec.docker.term">
  <title>Terminology</title>
  <para>
   The following list contains important terminology and introduces you
   to certain fundamental concepts of Docker.
  </para>
  <variablelist>
   <varlistentry>
    <term>chroot</term>
    <listitem>
     <para>
      A change root (chroot, or change root jail) is a section in the file system
      which is isolated from the rest of the file system. For this purpose, the
      chroot command is used to change the root of the file system. A program which is
      executed in such a chroot jail cannot access files outside the designated
      directory tree.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry id="vle.docker.cgroup">
    <term>cgroups</term>
    <listitem>
     <para>
      <remark>sknorr, 2014-07-16: "groups are [=plural] a feature that allows [=singular]".
      Unsure if that is good English or how to do it better.</remark>
      Control Groups are a
      kernel feature that allows aggregating or partitioning tasks (processes) and all
      their children into hierarchically organized groups to isolate resources.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Image</term>
    <listitem>
     <para>
      A <emphasis>virtual machine</emphasis> on the host server that can run any Linux system, for
      example &sls;, &sled;, or &opensuse;.
      A Docker image is made by a series of layers built one over the other. Each
      layer corresponds to a permanent change committed from a container to the image.
      For more details, see the official Docker documentation at
      <ulink url="http://docs.docker.com/terms/image/"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Image Name</term>
    <listitem>
     <para>
      A name that refers to an image. The name is used by the Docker commands.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Container</term>
    <listitem>
     <para>
      A running Docker image.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Container ID</term>
    <listitem>
     <para>
      An ID that refers to a particular container. The ID is used by the Docker commands.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Tag</term>
    <listitem>
     <para>
      A string associated with an image. It is commonly used to identify a specific
      version of an image (similar to tags in version control systems). It is also possible to
      refer the same image with different tags.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry id="vle.docker.namespace">
    <term>Kernel Namespaces</term>
    <listitem>
     <para>
      Namespaces are a kernel feature to isolate some resources like network,
      users, and others for a group of processes.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Docker Host Server</term>
    <listitem>
     <para>
      The system that runs the Docker daemon, and provides images and
      management control capabilities through <xref linkend="vle.docker.cgroup"/>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 
 <sect1 id="sec.docker.overview">
  <title>Overview</title>
  <para>
   Docker is a platform that allows developers and system administrators to manage the
   complete life cycle of images.
   Docker makes it easy to build, ship and run images containing
   applications.
  </para>

  <itemizedlist>
   <title>Benefits of Docker</title>
   <listitem>
    <para>
     Isolation of applications and operating systems through containers.
    </para>
   </listitem>
   <listitem>
    <para>
     Near native performance, as Docker manages allocation
     of resources in real-time.
    </para>
   </listitem>
   <listitem>
    <para>
     Controls network interfaces and resources available inside containers
     through cgroups.
    </para>
   </listitem>
   <listitem>
    <para>Versioning of images.</para>
   </listitem>
   <listitem>
    <para>Allows building new images based on existing ones.</para>
   </listitem>
   <listitem>
    <para>
     Docker Hub allows sharing and storing of images on <ulink
     url="http://docs.docker.com/docker-hub/">public</ulink>
     or <ulink
     url="http://docs.docker.com/userguide/dockerrepos/#private-repositories">
     private</ulink> repositories.
    </para>
   </listitem>
  </itemizedlist>

  <itemizedlist>
   <title>Limitations of Docker</title>
   <listitem>
    <para>
     Containers run inside the host system's kernel and
     cannot use a different kernel.
    </para>
   </listitem>
   <listitem>
    <para>
     Only allows Linux <emphasis>guest</emphasis> operating systems.
    </para>
   </listitem>
   <listitem>
    <para>
     Docker is not a full virtualization stack like &xen;, &kvm;, or &libvirt;.
    </para>
   </listitem>
   <listitem>
    <para>
     Security depends on the host system. Refer to the 
     <ulink url="http://docs.docker.com/articles/security/">official
     security documentation</ulink> for more details.
    </para>
   </listitem>
  </itemizedlist>

  <sect2 id="sec.docker.containerd">
   <title>Container Drivers</title>
   <para>
    Docker has different back-end drivers to handle containers. The recommended
    one is <ulink url="https://github.com/docker/libcontainer">
    libcontainer</ulink>, which is also the default choice. This driver
    provides direct access with <xref linkend="vle.docker.cgroup"/>.
    The Docker packages also ship an &lxc; driver which handles containers using the
    &lxc; tools. At the time of writing, the upstream project is working on a 
    <systemitem class="library">libvirt-lxc</systemitem> driver.
   </para>
  </sect2>
  
  <sect2 id="sec.docker.storaged">
   <title>Storage Drivers</title>
   <para>
     Docker supports different storage drivers:
   </para>
   <itemizedlist>
     <listitem>
       <para>
         <systemitem class="library">vfs</systemitem>: this driver is automatically used when
         the Docker host filesystem does not support copy-on-write. This is a simple driver
         which does not offer some of the advantages of Docker (like sharing layers, more on that in
         the next sections). It is highly reliable but also slow.
       </para>
     </listitem>
     <listitem>
       <para>
         <systemitem class="library">devicemapper</systemitem>: this driver relies on the device-mapper
         thin provisioning module. It supports copy-on-write, hence it offers all the advantages of
         Docker.
       </para>
     </listitem>
     <listitem>
       <para>
         <systemitem class="library">btrfs</systemitem>: this driver relies on Btrfs to provide all the
         features required by Docker. To use this driver the <filename>/var/lib/docker</filename>
         directory must be on a btrfs filesystem.
       </para>
     </listitem>
     <listitem>
       <para>
         <systemitem class="library">AUFS</systemitem>: this driver relies on AUFS union filesystem. Neither the
         upstream kernel nor the SUSE one supports this filesystem. Hence the AUFS driver is not built into the SUSE
         Docker package.
       </para>
     </listitem>
   </itemizedlist>
   <para>
     SLE12 uses the btrfs filesystem by default, which leads Docker to use the btrfs driver.
   </para>
   <para>
     It is possible to specify which driver to use by changing the value of the
     <systemitem class="library">DOCKER_OPTS</systemitem> variable defined inside of the
     <filename>/etc/sysconfig/docker</filename> file.
     This can be done either manually or using &yast; by browsing to
     <menuchoice>
       <guimenu>System</guimenu>
       <guimenu>/etc/sysconfig Editor</guimenu>
       <guimenu>System</guimenu>
       <guimenu>Management</guimenu>
       <guimenu>DOCKER_OPTS</guimenu>
     </menuchoice>
     menu and entering the <systemitem class="library">-s storage_driver</systemitem> string.
   </para>
   <para>
     For example, to force the usage of the <systemitem class="library">devicemapper</systemitem> driver
     enter the following text:
   </para>
   <screen>DOCKER_OPTS="-s devicemapper</screen>
   <note>
     <para>
       It is recommended to have <filename>/var/lib/docker</filename> mounted on a different filesystem
       to not affect the Docker host OS in case of a filesystem corruption.
     </para>
   </note>

  </sect2>
 </sect1>

 <sect1 id="sec.docker.setup">
  <title>Setting Up a Docker Host</title>
  <para></para>
  
  <sect2 id="sec.docker.setup.general">
   <title>General Preparation</title>
   <para>
    Prepare the host:
   </para>
   <procedure>
    <step>
     <para>
      Install the <systemitem>docker</systemitem> package.
     </para>
    </step>
   <step>
    <para>
     Automatically start the Docker daemon at boot:
    </para>
    <screen><command>sudo systemctl enable docker</command></screen>
   </step>
   <step>
    <para>
     Start the Docker daemon:
    </para>
    <screen><command>sudo systemctl start docker</command></screen>
   </step>
   </procedure>
   <para>
    The Docker daemon listens on a local socket which is accessible only by the
    <systemitem class="username">root</systemitem> user and by the members of the
    <systemitem class="groupname">docker</systemitem> group.
    The <systemitem class="groupname">docker</systemitem> group is automatically
    created at package installation time. To
    allow a certain user to connect to the local Docker daemon, use the following
   command:
   </para>
   <screen><command>sudo /usr/sbin/usermod -aG docker <replaceable>username</replaceable></command></screen>
   <para>
    The user can communicate with the local Docker daemon upon his next login.
   </para>
  </sect2>
  
  <sect2 id="sec.docker.setup.net">
   <title>Networking</title>
   <para>
    If you want your containers to be able to access the external network, you must
    enable the <option>ipv4 ip_forward</option> rule. This can be done using
    &yast; by browsing to
    <menuchoice>
     <guimenu>Network Devices</guimenu>
     <guimenu>Network Settings</guimenu>
     <guimenu>Routing</guimenu>
    </menuchoice>
    menu and ensuring <option>Enable IPv4 Forwarding</option> is checked.
   </para>
   <para>
    This option cannot be changed when networking is handled by the Network Manager.
    In such cases the <filename>/etc/sysconfig/SuSEfirewall2</filename>
    file needs to be edited by hand to ensure the 
    <option>FW_ROUTE</option> flag is set to <option>yes</option>:
   </para>
   <screen>FW_ROUTE="yes"</screen>
  </sect2>
 </sect1>
 <sect1 id="sec.docker.basic">
  <title>Basic Docker Operations</title>
  <para>
   Images can be pulled from Docker's central index at
   <ulink url="http://index.docker.io"/>
   using the following command:
   </para>
   <screen><command>docker pull <replaceable>image name</replaceable></command></screen>
  <para>
   Containers can be started using the <command>docker run</command> command.
   Refer to the official documentation of Docker at
   <ulink url="http://docs.docker.com/"/>
   for more details.
  </para>
 </sect1>

 <sect1 id="sec.docker.kiwi">
  <title>Using &kiwi; to Build Docker Containers </title>
  <para>
    Starting with version 5.06.8, &kiwi; can be used to build Docker images.
    Also see the official &kiwi; documentation, in particular
    <ulink url="https://doc.opensuse.org/projects/kiwi/doc/#chap.lxc"/>.
    The official <systemitem>kiwi-doc</systemitem> package contains examples
    of Docker images.
  </para>

  <para>
   Docker has an <ulink url="http://docs.docker.com/reference/builder/">internal build
   system</ulink> which allows creating new images based on existing ones.
   Some users might be confused about which to use for what task.
  </para>
  <para>
   The recommended approach is to build
   the <ulink url="http://docs.docker.com/terms/image/#base-image-def">base
   images</ulink> using &kiwi; and then use those as foundation blocks inside
   the Docker build system. This approach has two advantages:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     You can use Docker-specific directives (like
     <literal>ENTRYPOINT</literal>, <literal>EXPOSE</literal>, ...).
    </para>
    </listitem>
    <listitem>
     <para>
      You can re-use existing layers.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Sharing the common layers between different images makes it possible to:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Use less disk space on the Docker hosts.
     </para>
    </listitem>
    <listitem>
     <para>
      Deploy faster: only the requested layers are sent over the
      network (this is similar to upgrading installed packages using delta RPMs).
     </para>
    </listitem>
    <listitem>
     <para>
      Take full advantage of caching while building Docker images: this will
      result in faster executions of the <command>docker build</command> command.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    As you can see, &kiwi; is not to be intended as a replacement for Docker's build
    system, it complements it.
   </para>
 </sect1>

 <sect1 id="sec.docker.sle_images">
  <title>&sle; images for Docker</title>
  <para>
   Currently we cannot distribute SLE images for Docker because there is no way
   to associate an End-User License Agreement (EULA) to a Docker image.
   However we provide official &kiwi; templates and a convenience tool called
   <command>sle2docker</command> that can be used to build these images locally.
  </para>
  <sect2 id="sec.docker.sle_images.sle2docker_install">
   <title>Installing sle2docker</title>
   <para>
    The <command>sle2docker</command> tool is part of the official SLE12 repositories. It can be
    installed using the following command:
   </para>
   <screen><command>sudo zypper install sle2docker</command></screen>
   <note>
    <para>
     <command>sle2docker</command> requires the Docker daemon to be running on the
     system.
    </para>
   </note>
  </sect2>
  
  <sect2 id="sec.docker.sle_images.build">
   <title>Build Docker images</title>
   <para>
    The official SLE templates are shipped with the <command>sle2docker</command> package.
    Use the following command to list the available templates:
   </para>
   <screen><command>sle2docker <option>-l</option></command></screen>
   <para>
    Select a template and build it using the following command:
   </para>
   <screen><command>sle2docker <option>TEMPLATE_NAME</option></command></screen>
   <para>
    At the end of the build process <command>sle2docker</command> will print the command
    that can be used to import the image.
   </para>
   <sect3 id="sec.docker.sle_images.build.ncc">
    <title>Novell Customer Center integration</title>
    <para>
     By default <command>sle2docker</command> downloads all the required packages from &scc;
     . Before the build starts <command>sle2docker</command> asks the user his &scc;
     credentials. It is possible to start a build in a non interactive way
     by using the following command:
    </para>
    <screen><command>sle2docker -u USERNAME -p PASSWORD TEMPLATE_NAME</command></screen>
   </sect3>
   <sect3 id="sec.docker.sle_images.build.smt">
    <title>Subscription Management Tool integration</title>
    <para>
     It is possible to download all the required packages from a local
     &smt; (SMT) instance:
    </para>
    <screen>
     <command>sle2docker -s SMT_SERVER_HOSTNAME TEMPLATE_NAME</command>
      </screen>
      <para>
       By default <command>sle2docker</command> assumes the contents of the &smt; server are
       served over HTTPS. To force the retrieval of the package over plain HTTP
       use the following command:
      </para>
      <screen><command>sle2docker -s SMT_SERVER_HOSTNAME --disable-https TEMPLATE_NAME</command></screen>
      <para>
       By default <command>sle2docker</command> expects the &smt; instance to not require any form
       of authentication. However it is possible to specify the access
       credentials by using the following command:
      </para>
      <screen><command>sle2docker -s SMT_SERVER_HOSTNAME -u USERNAME -p PASSWORD TEMPLATE_NAME</command>
      </screen>
   </sect3>
  </sect2>
  <sect2 id="sec.docker.sle_images.how_the_build_process_works">
    <title>How the build process works</title>
    <para>
     The <command>sle2docker</command> package comes with a set of supported SLE templates. These
     are &kiwi; source files which are filled with the informations provided by
     the user at runtime.
    </para>
    <para>
     The image creation happens inside of
     <ulink url="https://registry.hub.docker.com/u/opensuse/kiwi/">this
     Docker image</ulink>ulink>. This is  done because on recent systems (like SLE12)
     &kiwi; cannot create SLE11 images. That happens because building a SLE11
     system requires the <systemitem class="library">db45-utils</systemitem>
     package to be installed on the host system; this package is obsolete and
     is not available on SLE12.
    </para>
    <para>
     The Docker image used by <command>sle2docker</command> is based on the &opensuse; one which
     is freely downloadable from the
     <ulink url="https://registry.hub.docker.com/">Docker Hub</ulink>. The
     image is built using Docker's build system by starting from the
     <ulink url="https://registry.hub.docker.com/_/opensuse/">
      official &opensuse; image</ulink>.
      The <systemitem class="library">Dockerfile</systemitem> used to create
      this image can be found inside of
      <ulink url="https://github.com/openSUSE/docker-containers">this
      repository</ulink>
    </para>
    <para>
     <command>sle2docker</command> automatically fetches the
     <systemitem class="library">opensuse/kiwi</systemitem> image if not found
     on the system.
    </para>
  </sect2>
 </sect1>
</article>
