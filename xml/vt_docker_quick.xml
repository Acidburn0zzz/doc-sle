<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd"
[
  <!ENTITY % NOVDOC.DEACTIVATE.IDREF "INCLUDE">
  <!ENTITY % entities SYSTEM "entity-decl.ent">
  %entities;
]>

<article id="article.docker" lang="en">
 <?suse-quickstart color="suse"?>
 <title>Docker Quick Start Guide</title>
 <articleinfo>
  <productname>&sle; &productname;</productname>
  <date>Jul 26, 2014</date>
 </articleinfo>

 <sect1 id="article.docker.abstract">
  <title>Abstract</title>
  <para>
   Docker is a lightweight <emphasis>virtualization</emphasis> method to run multiple virtual units
   (containers, akin to chroot) simultaneously on a single control host.
   Containers are isolated with Kernel Control Groups (<xref
   linkend="docker.cgroups"/>) and <xref linkend="docker.knm"/>.
  </para>
  <para>
   Docker provides an operating system-level virtualization where the Kernel
   controls the isolated containers. With other full virtualization solutions
   like Xen, KVM, or libvirt the processor simulates a complete hardware
   environment and controls its virtual machines.
  </para>
 </sect1>
 
 <sect1 id="article.docker.term">
  <title>Terminology</title>
  <variablelist>
   <varlistentry>
    <term>chroot</term>
    <listitem>
     <para>
      A change root (chroot, or change root jail) is a section in the file system
      which is isolated from the rest of the file system. For this purpose, the
      chroot command is used to change the root of the file system. A program which is
      executed in such a chroot jail cannot access files outside the designated
      directory tree.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry id="docker.cgroups">
    <term>cgroups</term>
    <listitem>
     <para>
      Kernel Control Groups are a
      Kernel feature that allows aggregating or partitioning tasks (processes) and all
      their children into hierarchical organized groups to isolate resources.       
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Image</term>
    <listitem>
     <para>
      A <emphasis>virtual machine</emphasis> on the host server that can run any Linux system, for
      example openSUSE, &sled;, or &sle;.
      A Docker image is made by a series of layers built one over the other. Each
      layer corresponds to a permanent change committed from a container to the image.
      For more details checkout 
      <ulink url="http://docs.docker.com/terms/image/">Docker's official documentation</ulink>
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
     <term>Image Name</term>
     <listitem>
      <para>
       A name that refers to an image. The name is used by the docker commands.       
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Container</term>
     <listitem>
      <para>
       A running Docker Image.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Container ID</term>
     <listitem>
      <para>
       A ID that refers to a container. The ID is used by the docker commands.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>TAG</term>
     <listitem>
      <para>
       A string associated to a Image. It commonly used to identify a specific
       version of a Image (like tags in version control systems). It is also possible to
       refer the same Image with different TAGs.       
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="docker.knm">
     <term>Kernel Namespaces</term>
     <listitem>
      <para>
       A Kernel feature to isolate some resources like network, users, and others for
       a group of processes.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Docker Host Server</term>
     <listitem>
      <para>
       The system that runs the Docker daemon, provides the images, and the
       management control capabilities through <xref linkend="docker.cgroups"/>.       
      </para>
     </listitem>
    </varlistentry>
  </variablelist>
 </sect1>
 
 <sect1 id="article.docker.overview">
  <title>Overview</title>
  <para>
   Docker is a platform that allows developers and sysadmins to manage the
   complete lifecycle of images.
   Docker makes incredibly easy to build, ship and run images containing
   applications.
  </para>
  <sect2 id="sect.docker.benefit">
   <title>Benefits of Docker</title>
   <itemizedlist>
    <listitem>
     <para>
      Isolating applications and operating systems through containers.
     </para>
    </listitem>
    <listitem>
     <para>
      Providing nearly native performance as Docker manages allocation
      of resources in real-time.
     </para>
    </listitem>
    <listitem>
     <para>
      Controlling network interfaces and applying resources inside containers
      through cgroups
     </para>
    </listitem>
    <listitem>
     <para>Versioning of images.</para>
    </listitem>
    <listitem>
     <para>Building images based on existing ones.</para>
    </listitem>
    <listitem>
     <para>
      Sharining/storing on <ulink
      url="http://docs.docker.com/docker-hub/">public</ulink>
      or <ulink
      url="http://docs.docker.com/userguide/dockerrepos/#private-repositories">
      private</ulink> repositories.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>
  
  <sect2 id="sect.docker.limit">
   <title>Limitations of Docker</title>
   <itemizedlist>
    <listitem>
     <para>
      All Docker containers are running inside the host system's Kernel and
      not with a different Kernel.
     </para>
    </listitem>
    <listitem>
     <para>
      Only allows Linux <emphasis>guest</emphasis> operating systems.
     </para>
    </listitem>
    <listitem>
     <para>
      Docker is not a full virtualization stack like Xen, KVM, or libvirt.
     </para>
    </listitem>
    <listitem>
     <para>
      Security depends on the host system. Refer to the 
      <ulink url="http://docs.docker.com/articles/security/">official
      security documentation</ulink> for more details.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>
  
  <sect2 id="sec.docker.containerd">
   <title>Container drivers</title>
   <para>
    Docker has different backend drivers to handle the containers. The recommended
    on is <ulink url="https://github.com/docker/libcontainer">
    libcontainer</ulink>, which is also the default choice. This driver
    provides direct access with <xref linkend="docker.cgroups"/>.
    The Docker packages ships also a LXC driver which handles containers using the
    LXC tools. At the time of writing, upstream is working on a 
    <emphasis>libvirt-lxc</emphasis> driver.
   </para>
  </sect2>
  
  <sect2 id="sec.docker.storaged">
   <title>Storage drivers</title>
   <para>
    Docker images are made by series of stacked layers. The recommended driver is
    DeviceMapper one, which is also the default choice.
    The Docker packages ships also an experimental BTRFS driver. To use this
    driver Docker daemon must run on a BTRFS partition already prepared by the host
    system.
   </para>
   <para>
    To use the experimental BTRFS driver the Docker daemon must be started with
    this command:
   </para>
   <screen>docker -d -s btrfs</screen>
  </sect2>
 </sect1>

 <sect1 id="sec.docker.setup">
  <title>Setting up a Docker host</title>
  <para>
   Prepare the host:
  </para>
  <procedure>
   <step>
    <para>
     Install the `docker` package.
    </para>
   </step>
   <step>
    <para>
     Automatically start the Docker daemon at boot:
    </para>
    <screen>sudo systemctl enable docker</screen>
   </step>
   <step>
    <para>
     Start the Docker daemon:
    </para>
    <screen>sudo systemctl start docker</screen>
   </step>
  </procedure>
  <para>
   The Docker daemon listens on a local socket which is accessible only by the
   <emphasis>root</emphasis> user and by the members of the <emphasis>docker</emphasis> group.
   The <emphasis>docker</emphasis> group is automatically created at package installation time. To
   allow a certain user to connect to the local Docker daemon use the following
   command:
  </para>
  <screen>sudo /usr/sbin/usermod -aG docker <replaceable>username</replaceable></screen>   
 <para>
  The user will be able to communicate with the local Docker daemon upon his
  next login.
 </para>
 </sect1>
 
 <sect1 id="article.docker.basic">
  <title>Basic Docker operations</title>
  <para>
   Images can be pulled from [Docker's central index](http://index.docker.io)
   using
   the following command:
   <command>docker pull <replaceable>image name</replaceable></command>
  </para>
  <para>
   Containers can be started using the <command>docker run</command> command.
   Please refer to the
   <ulink url="http://docs.docker.com/">official documentation</ulink>
   for more details.
  </para>
 </sect1>
 
 <sect1 id="article.docker.kiwi">
  <title>Building Docker containers using KIWI</title>
  <para></para>
  <sect2 id="sec.docker.kiwi">
   <title>Kiwi</title>
   <para>
    Starting from version 5.06.8 KIWI can be used to build Docker images.
    Please refer to <ulink url="https://doc.opensuse.org/projects/kiwi/doc/#chap.lxc">KIWI's 
    official documentation</ulink>.
    The official <emphasis>kiwi-doc</emphasis> package contains examples of Docker images.
   </para>
  </sect2>
  
  <sect2 id="sec.docker.kiwivsdocker">
   <title>Docker build system versus KIWI</title>
   <para>
    Docker has an <ulink url="http://docs.docker.com/reference/builder/">internal build
    system</ulink> which makes incredibly easy to create new images based on existing ones.
   </para>
   <para>
   Some users might be confused about what to use. The right approach is to build
   the <ulink url="http://docs.docker.com/terms/image/#base-image-def">base
   images</ulink> using KIWI and then use them as foundation blocks inside of
   your Docker's build system.
   </para>
   <para>
    That two advantages:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Be able to use docker specific directives (like `ENTRYPOINT`, `EXPOSE`,
      ...).
     </para>
    </listitem>
    <listitem>
     <para>
      Be able to reuse already existing layers.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Sharing the common layers between different images makes possible to:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Use less disk space on the Docker hosts.
     </para>
    </listitem>
    <listitem>
     <para>
      Make the deployments faster: only the requested layers are sent over the
      network (it is like upgrading installed packages using delta rpms).
     </para>
    </listitem>
    <listitem>
     <para>
      Take full advantage of caching while building Docker images: this will
      result in faster executions of `docker build` command.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    To recap: KIWI is not to be intended as a replacement for Docker's build
    system. It rather complements with it.
   </para>
  </sect2>
 </sect1>
</article>
