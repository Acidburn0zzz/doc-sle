<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha.multitiercache" xml:lang="en">
 <title>Multitier Caching for Block Device Operations</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  A multitier cache is a replicated/distributed cache that consists of at
  least two tires: one is represented by a slower but cheaper rotational
  block devices (HDD), while the other is more expensive but performs faster
  data operations (for example SSD flash disks).
 </para>
 <para>
  &sls; implements two different solutions for caching between flash and
  rotational devices: &dmcache; and &bcache;.
 </para>
 <sect1 xml:id="terminology">
  <title>Terminology</title>

  <para>
   This section explains several terms often used when describing cache
   related features:
  </para>

  <variablelist>
   <varlistentry>
    <term>Migration</term>
    <listitem>
     <para>
      Movement of the primary copy of a logical block from one device to the
      other.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Promotion</term>
    <listitem>
     <para>
      Migration from the slow device to the fast device.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Demotion</term>
    <listitem>
     <para>
      Migration from the fast device to the slow device.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Origin device</term>
    <listitem>
     <para>
      The big and slower block device. It always contains a copy of the
      logical block, which may be out of date or kept in sync with the copy
      on the cache device (depending on policy).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Cache device</term>
    <listitem>
     <para>
      The small and faster block device.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Metadata device</term>
    <listitem>
     <para>
      A small device that records which blocks are in the cache, which are
      dirty, and extra hints for use by the policy object. This information
      could be put on the cache device as well, but having it separate
      allows the volume manager to configure it differently. For example as
      a mirror for extra robustness. The metadata device may only be used by
      a single cache device.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Dirty block</term>
    <listitem>
     <para>
      If some process writes to a block of data which is placed in the
      cache, the cached block is marked as <emphasis>dirty</emphasis>
      because it was overwritten in the cache and needs to be written back
      to the original device.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Cache miss</term>
    <listitem>
     <para>
      A request for I/O operations is pointed to the cached device's cache
      first. If it cannot find the requested values, it looks into the
      device itself, which is slow. This is called a <emphasis>cache
      miss</emphasis>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Cache hit</term>
    <listitem>
     <para>
      When a requested value is found in the cached device's cache, it is
      served fast. This is called a <emphasis>cache hit</emphasis>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Cold cache</term>
    <listitem>
     <para>
      Cache that holds no values (is empty) and causes <emphasis>cache
      misses</emphasis>. As the cached block device operations progress, it
      gets filled with data and becomes <emphasis>warm</emphasis>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Warm cache</term>
    <listitem>
     <para>
      Cache that already holds some values and is probable to cause
      <emphasis>cache hits</emphasis> .
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="multitiercache.caching_modes">
  <title>Caching Modes</title>

  <para>
   Following are the basic caching modes that multitier caches use:
   <emphasis>write-back</emphasis>, <emphasis>write-through</emphasis>, and
   <emphasis>pass-through</emphasis>.
  </para>

  <variablelist>
   <varlistentry>
    <term>write-back</term>
    <listitem>
     <para>
      Data written to a block that is cached go to the cache only, and the
      block is marked dirty. This is the default caching mode.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>write-through</term>
    <listitem>
     <para>
      Writing to a cached block will not complete until it has hit both the
      origin and cache devices. Clean blocks remain clean with
      <emphasis>write-through</emphasis> cache.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>write-around</term>
    <listitem>
     <para>
      A similar technique to write-through cache, but write I/O is written
      directly to a permanent storage, bypassing the cache. This can reduce
      the cache being flooded with write I/O that will not subsequently be
      re-read, but the disadvantage is that a read request for recently
      written data will create a 'cache miss' and have to be read from
      slower bulk storage and experience higher latency.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>pass-through</term>
    <listitem>
     <para>
      To enable the <emphasis>pass-through</emphasis> mode, the cache needs
      to be clean. Reading is served from the origin device bypassing the
      cache. Writing is forwarded to the origin device and 'invalidates' the
      cache block. <emphasis>Passthrough</emphasis> allows a cache device
      activation without having to care about data coherency, which is
      maintained. The cache will gradually become cold as writing takes
      place. If you can verify the coherency of the cache later, or
      establish it by using the 'invalidate_cblocks' message, you can switch
      the cache device to <emphasis>write-through</emphasis> or
      <emphasis>write-back</emphasis> mode while it is still warm.
      Otherwise, you can discard the cache contents before switching to the
      desired caching mode.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   A simple cleaner policy is provided, which cleans (write back) all dirty
   blocks in a cache. It is useful when decommissioning or shrinking the
   cache. Shrinking the cache's fast device requires all cache blocks to be
   clean. If the area being removed from the cache still contains dirty
   blocks, the resize fails. You must never reduce the volume used for the
   cache's fast device until the cache is clean. This is very important
   importance if <emphasis>write-back</emphasis> mode is used.
   <emphasis>Write-through</emphasis> and <emphasis>pass-through</emphasis>
   modes already maintain a clean cache.
  </para>
 </sect1>
 <sect1 xml:id="dm-cache">
  <title>&dmcache;</title>

  <para>
   &dmcache; is a device mapper target that improves performance of a block
   device by dynamically migrating some of its data to a faster, smaller
   device. Existing plug-ins decide what data to migrate and when.
  </para>

  <sect2 xml:id="dm-cache.migration_throttling">
   <title>Migration Throttling</title>
   <para>
    Migrating data between the origin and cache device uses some bandwidth.
    You can set a 'throttle' to prevent more than a certain amount of
    migration occurring at one time.
   </para>
   <para>
    To set the maximum number of sectors being migrated, use the
    <option>migration_threshold
    <replaceable>num_of_sectors</replaceable></option> message. The default
    is 204800 sectors (that is 100MB).
   </para>
  </sect2>

  <sect2 xml:id="dm-cache.policy_messaging">
   <title>Policy Messaging</title>
   <para>
    Policies have different sets of tunables specific to each one. To reach
    a generic way of getting and setting tunable values, the device-mapper
    messages are used. For more information on cache policies, see the
    contents of
    <filename>/usr/share/doc/packages/lvm2/kernel/cache-policies.txt</filename>.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="bcache">
  <title>&bcache;</title>

<!-- https://bcache.evilpiepirate.org/ -->

  <para>
   &bcache; is a Linux kernel block layer cache. It allows one or more fast
   disk drives (such as SSDs) to act as a cache for one or more slower hard
   disk drives. &bcache; supports write-through and write-back, and is
   independent of the file system used. By default it caches random reads
   and writes only where SSDs excel at. It is suitable for both desktops,
   servers, and high end storage arrays as well.
  </para>

  <sect2 xml:id="bcache.features">
   <title>Main Features</title>
   <itemizedlist>
    <listitem>
     <para>
      A single cache device can be used to cache an arbitrary number of
      backing devices. Backing devices can be attached and detached at
      runtime, while mounted and in use.
     </para>
    </listitem>
    <listitem>
     <para>
      Recovers from unclean shutdowns&mdash;writes are not completed until
      the cache is consistent with respect to the backing device.
     </para>
    </listitem>
    <listitem>
     <para>
      Throttles traffic to the SSD if it becomes congested.
     </para>
    </listitem>
    <listitem>
     <para>
      Highly efficient write-back implementation. Dirty data is always
      written out in sorted order.
     </para>
    </listitem>
    <listitem>
     <para>
      Stable and reliable&mdash;in production use.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

<!-- https://wiki.archlinux.org/index.php/Bcache#Setting_up_a_bcache_device_on_an_existing_system -->

  <sect2 xml:id="bcache.setting_bcache_device">
   <title>Setting Up a &bcache; Device</title>
   <para>
    This section describes steps to set up and manage a &bcache; device.
   </para>
   <procedure>
    <step>
     <para>
      Install the <systemitem>bcache-tools</systemitem> package:
     </para>
<screen>sudo zypper in bcache-tools</screen>
    </step>
    <step>
     <para>
      Create a backing device (typically a mechanical drive). The backing
      device can be a whole device, a partition, or any other standard block
      device.
     </para>
<screen>sudo make-bcache -B /dev/sdb</screen>
    </step>
    <step>
     <para>
      Create a cache device (typically an SSD disk).
     </para>
<screen>sudo make-bcache -C /dev/sdc</screen>
     <para>
      In this example, the default block and bucket sizes of 512B and 128kB
      are used. The block size should match the backing devices sector size
      which will usually be either 512 or 4k. The bucket size should match
      the erase block size of the caching device with the intent of reducing
      write amplification. For example, using a HDD with 4k sectors and an
      SSD with an erase block size of 2MB this command would look as
      follows:
     </para>
<screen>sudo make-bcache --block 4k --bucket 2M -C /dev/sdc</screen>
     <tip>
      <para>
       <command>make-bcache</command> can prepare and register multiple
       backing devices and a cache device at the same time. In this case you
       do not need to manually attach the cache device to the backing device
       afterwards:
      </para>
<screen>sudo make-bcache -B /dev/sda /dev/sdb -C /dev/sdc</screen>
     </tip>
    </step>
    <step>
     <para>
      &bcache; devices show up as
     </para>
<screen>/dev/bcache<replaceable>N</replaceable></screen>
     <para>
      as well as
     </para>
<screen>/dev/bcache/by-uuid/<replaceable>uuid</replaceable>
/dev/bcache/by-label/<replaceable>label</replaceable></screen>
     <para>
      You can normally format and mount &bcache; devices as usual:
     </para>
<screen>mkfs.ext4 /dev/bcache0
mount /dev/bcache0 /mnt</screen>
     <para>
      You can control &bcache; devices through
      <systemitem>sysfs</systemitem> at
      <filename>/sys/block/bcache<replaceable>N</replaceable>/bcache</filename>.
     </para>
    </step>
    <step>
     <para>
      After both the cache and backing devices are registered, you need to
      attach the backing device to the related cache set to enable caching:
     </para>
<screen>echo <replaceable>cache_set_uuid</replaceable> > /sys/block/bcache0/bcache/attach</screen>
     <para>
      where <replaceable>cache_set_uuid</replaceable> is found in
      <filename>/sys/fs/bcache</filename>.
     </para>
    </step>
    <step>
     <para>
      By default &bcache; uses a pass-through caching mode. To change it to
      for example write-back, run
     </para>
<screen>echo writeback > /sys/block/bcache0/bcache/cache_mode</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="bcache.sysfs">
   <title>&bcache; Configuration using <systemitem>sysfs</systemitem></title>
   <para>
    &bcache; devices use the <systemitem>sysfs</systemitem> interface to
    store their runtime configuration values. This way you can change
    &bcache; backing and cache disks behavior or see their usage statistics.
   </para>
   <para>
    For the complete list of &bcache; <systemitem>sysfs</systemitem>
    parameters, see the contents of the
    <filename>/usr/src/linux/Documentation/bcache.txt</filename> file,
    mainly the <literal>SYSFS - BACKING DEVICE</literal>, <literal>SYSFS -
    BACKING DEVICE STATS</literal>, and <literal>SYSFS - CACHE
    DEVICE</literal> sections.
   </para>
  </sect2>
 </sect1>
</chapter>
