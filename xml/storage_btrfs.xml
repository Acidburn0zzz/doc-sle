<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<!-- Converted by suse-upgrade version 1.1 -->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="sec.filesystems.major.btrfs" xml:lang="en">
 <title>Btrfs</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker>
   </dm:bugtracker>
   <dm:translation>yes</dm:translation>
  </dm:docmanager>
 </info>
 <para>
  Btrfs is a copy-on-write (COW) file system developed by Chris Mason. It
  is based on COW-friendly B-trees developed by Ohad Rodeh. Btrfs is a
  logging-style file system. Instead of journaling the block changes, it
  writes them in a new location, then links the change in. Until the last
  write, the new changes are not committed.
 </para>
 <sect1 xml:id="sec.filesystems.major.btrfs.features">
  <title>Key Features</title>
  <para>
   Btrfs provides fault tolerance, repair, and easy management features,
   such as the following:
  </para>
  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     Writable snapshots that allow you to easily roll back your system if
     needed after applying updates, or to back up files.
    </para>
   </listitem>
   <listitem>
    <para>
     Subvolume support: Btrfs creates a default subvolume in its assigned
     pool of space. It allows you to create additional subvolumes that act
     as individual file systems within the same pool of space. The number
     of subvolumes is limited only by the space allocated to the pool.
    </para>
   </listitem>
   <listitem>
    <para>
     The online check and repair functionality <command>scrub</command> is
     available as part of the Btrfs command line tools. It verifies the
     integrity of data and metadata, assuming the tree structure is fine.
     You can run scrub periodically on a mounted file system; it runs as a
     background process during normal operation.
    </para>
   </listitem>
   <listitem>
    <para>
     Different RAID levels for metadata and user data.
    </para>
   </listitem>
   <listitem>
    <para>
     Different checksums for metadata and user data to improve error
     detection.
    </para>
   </listitem>
   <listitem>
    <para>
     Integration with Linux Logical Volume Manager (LVM) storage objects.
    </para>
   </listitem>
   <listitem>
    <para>
     Integration with the &yast; Partitioner and &ay; on
     &productname;. This also includes creating a Btrfs file system on
     Multiple Devices (MD) and Device Mapper (DM) storage configurations.
    </para>
   </listitem>
   <listitem>
    <para>
     Offline migration from existing Ext2, Ext3, and Ext4 file systems.
    </para>
   </listitem>
   <listitem>
    <para>
     Boot loader support for <filename>/boot</filename>, allowing to boot
     from a Btrfs partition.
    </para>
   </listitem>
   <listitem>
    <!--taroth 2015-08-07: fix for http://doccomments.provo.novell.com/comments/28887-->
      <para>
       Multivolume Btrfs is supported in RAID0, RAID1, and RAID10 profiles
       in &productname; &productnumber;. Higher RAID levels are not
       supported yet, but might be enabled with a future service pack.
      </para>
   </listitem>
   <listitem>
    <para>
     Use Btrfs commands to set up transparent compression.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
 <sect1 xml:id="sec.filesystems.major.btrfs.suse">
  <title>The Root File System Setup on &productname;</title>
  <para>
   By default, &productname; is set up using Btrfs and snapshots for
   the root partition. Snapshots allow you to easily roll back your system
   if needed after applying updates, or to back up files. Snapshots can
   easily be managed with the &suse; Snapper infrastructure as
   explained in <xref linkend="cha.snapper"/>. For general information
   about the &suse; Snapper project, see the Snapper Portal wiki at
   OpenSUSE.org (<link xlink:href="http://snapper.io"/>).
  </para>
  <para>
   When using a snapshot to roll back the system, it must be ensured that
   data such as user's home directories, Web and FTP server contents or
   log files do not get lost or overwritten during a roll back. This is
   achieved by using Btrfs subvolumes on the root file system. Subvolumes
   can be excluded from snapshots. The default root file system setup on
   &productname; as proposed by &yast; during the installation
   contains the following subvolumes. They are excluded from snapshots for
   the reasons given below.
  </para>

  <xi:include href="snapshot_excludes_i.xml"/>

  <warning>
   <title>Support for Rollbacks</title>
   <para>
    Rollbacks are only supported by the &suse; support if you do not
    remove any of the preconfigured subvolumes. You may, however, add
    additional subvolumes using the &yast; Partitioner.
   </para>
  </warning>
  <sect2 xml:id="sec.filesystems.major.btrfs.compress">
   <title>Mounting Compressed Btrfs File Systems</title>
   <remark>toms 2015-09-16: FATE#316463</remark>
   <note>
    <title>&grub; and LZO Compressed Root</title>
    <para>&grub; cannot read an lzo compressed root. You need a separate
    <filename>/boot</filename> partition if you want to use
    compression.</para>
   </note>
   <para>
    Since &slea;12 SP1, compression for Btrfs file systems is
    supported.  Use the <option>compress</option> or
    <option>compress-force</option> option and select the compression
    algorithm, <literal>lzo</literal> or <literal>zlib</literal> (the
    default). The zlib compression has a higher compression ratio while lzo
    is faster and takes less CPU load.
   </para>
   <para>
    For example:
   </para>
   <screen>&prompt.root;mount -o compress /dev/sdx /mnt</screen>
   <para>
    In case you create a file, write to it, and the compressed result is
    greater or equal to the uncompressed size, Btrfs will skip compression
    for future write operations forever for this file.  If you do not like
    this behavior, use the <option>compress-force</option> option. This can
    be useful for files that have some initial uncompressible data.
   </para>
   <para>
    Note, compression takes effect for new files only. Files that were
    written without compression are not compressed when the file system is
    mounted with the <option>compress</option> or
    <option>compress-force</option> option.  Furthermore, files with the
    <option>nodatacow</option> attribute never get their extents
    compressed:
   </para>
   <screen>&prompt.root;<command>chattr</command> +C <replaceable>FILE</replaceable>
   &prompt.root;<command>mount</command> -o nodatacow  /dev/sdx /mnt</screen>
   <para>
    In regard to encryption, this is independent from any compression.
    After you have written some data to this partition, print the details:
   </para>
   <screen>&prompt.root;btrfs filesystem show /mnt
btrfs filesystem show /mnt
Label: 'Test-Btrfs'  uuid: 62f0c378-e93e-4aa1-9532-93c6b780749d
      Total devices 1 FS bytes used 3.22MiB
      devid    1 size 2.00GiB used 240.62MiB path /dev/sdb1</screen>
   <para>
    If you want this to be permanent, add the <option>compress</option> or
    <option>compress-force</option> option into the
    <filename>/etc/fstab</filename> configuration file. For example:
   </para>
   <screen>UUID=1a2b3c4d /home btrfs subvol=@/home,<emphasis role="strong">compress</emphasis> 0 0</screen>
  </sect2>
  <sect2 xml:id="sec.filesystems.major.btrfs.suse.mount">
   <title>Mounting Subvolumes</title>
   <para>
    A system rollback from a snapshot on &productname; is performed by booting
    from the snapshot first. This allows you to check the snapshot while
    running before doing the rollback. Being able to boot from snapshots is
    achieved by mounting the subvolumes (which would normally not be
    necessary).
   </para>
   <para>
    In addition to the subvolumes listed at <xref
    linkend="sec.filesystems.major.btrfs.suse"/> a volume named
    <literal>@</literal> exists. This is the default subvolume that will be
    mounted as the root partition (<filename>/</filename>). The other
    subvolumes will be mounted into this volume.
   </para>
   <para>
    When booting from a snapshot, not the <literal>@</literal> subvolume will
    be used, but rather the snapshot. The parts of the file system included in
    the snapshot will be mounted read-only as <filename>/</filename>. The other
    subvolumes will be mounted writable into the snapshot. This state is
    temporary by default: the previous configuration will be restored with the
    next reboot. To make it permanent, execute the <command>snapper
    rollback</command> command.  This will make the snapshot that is currently
    booted the new <emphasis>default</emphasis> subvolume, which will be used
    after a reboot.
   </para>
  </sect2>
  <sect2 xml:id="sec.filesystems.major.btrfs.suse.space">
   <title>Checking for Free Space</title>
   <para>
    File system usage is usually checked by running the
    <command>df</command> command. On a Btrfs file system, the output of
    <command>df</command> can be misleading, because in addition to the
    space the raw data allocates, a Btrfs file system also allocates and
    uses space for metadata.
   </para>
   <para>
    Consequently a Btrfs file system may report to be out of space although
    it seems that plenty of space is still available. In that case, all
    space allocated for the metadata is used up. Use the following commands
    to check for used and available space on a Btrfs file system:
   </para>
   <variablelist>
    <varlistentry>
     <term><command>btrfs filesystem show</command></term>
     <listitem>
      <screen>&prompt.user;sudo btrfs filesystem show /
Label: 'ROOT'  uuid: 52011c5e-5711-42d8-8c50-718a005ec4b3
        Total devices 1 FS bytes used 10.02GiB
        devid    1 size 20.02GiB used 13.78GiB path /dev/sda3</screen>
      <para>
       Shows the total size of the file system and its usage. If both values in
       the last line match, all space on the file system has been allocated.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><command>btrfs filesystem df</command></term>
     <listitem>
      <screen>&prompt.user;sudo btrfs file system df /
Data, single: total=13.00GiB, used=9.61GiB
System, single: total=32.00MiB, used=16.00KiB
Metadata, single: total=768.00MiB, used=421.36MiB
GlobalReserve, single: total=144.00MiB, used=0.00B</screen>
      <para>
       Shows values for allocated (<literal>total</literal>) and used space of
       the file system. If the values for <literal>total</literal> and
       <literal>used</literal> for the metadata are almost equal, all space for
       metadata has been allocated.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><command>btrfs filesystem usage</command></term>
     <listitem>
      <screen>&prompt.user;sudo btrfs filesystem usage /
Overall:
    Device size:                  20.02GiB
    Device allocated:             13.78GiB
    Device unallocated:            6.24GiB
    Device missing:                  0.00B
    Used:                         10.02GiB
    Free (estimated):              9.63GiB      (min: 9.63GiB)
    Data ratio:                       1.00
    Metadata ratio:                   1.00
    Global reserve:              144.00MiB      (used: 0.00B)

             Data     Metadata  System
Id Path      single   single    single   Unallocated
-- --------- -------- --------- -------- -----------
 1 /dev/sda3 13.00GiB 768.00MiB 32.00MiB     6.24GiB
-- --------- -------- --------- -------- -----------
   Total     13.00GiB 768.00MiB 32.00MiB     6.24GiB
   Used       9.61GiB 421.36MiB 16.00KiB</screen>
      <para>
       Shows similar data as the two previous commands combined.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    For more information refer to <command>man 8 btrfs-filesystem</command>
    and <link xlink:href="https://btrfs.wiki.kernel.org/index.php/FAQ"/>.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.filesystems.major.btrfs.migrate">
  <title>Migration from Ext and ReiserFS File Systems to Btrfs</title>
  <para>
   You can migrate data volumes from existing Ext (Ext2, Ext3, or Ext4) or
   ReiserFS to the Btrfs file system. The conversion process occurs
   offline and in place on the device. The file system needs at least 15%
   of available free space on the device.
  </para>
  <para>
   To convert the file system to Btrfs, take the file system offline, then
   enter:
  </para>
  <screen>sudo btrfs-convert &lt;<replaceable>device</replaceable>&gt;</screen>
  <para>
   To roll back the migration to the original file system, take the file system
   offline, then enter:
  </para>
  <screen>sudo btrfs-convert -r &lt;<replaceable>device</replaceable>&gt;</screen>

  <warning>
   <title>Root File System Conversion not Supported</title>
   <para>
    Converting the root file system to Btrfs is not supported. Either keep the
    existing file system or re-install the whole system from scratch.
   </para>
  </warning>

  <important>
   <title>Possible Loss of Data</title>
   <para>
    When rolling back to the original file system, all data will be lost that
    you added after the conversion to Btrfs. That is, only the original data is
    converted back to the previous file system.
   </para>
  </important>
 </sect1>
 <sect1 xml:id="sec.filesystems.major.btrfs.admin">
  <title>Btrfs Administration</title>
  <para>
   Btrfs is integrated in the &yast; Partitioner and &ay;. It is available
   during the installation to allow you to set up a solution for the root file
   system. You can use the &yast; Partitioner after the installation to view
   and manage Btrfs volumes.
  </para>
  <para>
   Btrfs administration tools are provided in the
   <filename>btrfsprogs</filename> package. For information about using Btrfs
   commands, see the <command>man 8 btrfs</command>, <command>man 8
   btrfsck</command>, and <command>man 8 mkfs.btrfs</command> commands.  For
   information about Btrfs features, see the <citetitle>Btrfs wiki</citetitle>
   at <link xlink:href="http://btrfs.wiki.kernel.org"/>.
  </para>
 </sect1>
 <sect1 xml:id="sec.filesystems.major.btrfs.quota">
  <title>Btrfs Quota Support for Subvolumes</title>
  <para>
   The Btrfs root file system subvolumes <filename>/var/log</filename>,
   <filename>/var/crash</filename> and <filename>/var/cache</filename> can use
   all of the available disk space during normal operation, and cause a system
   malfunction. To help avoid this situation, &productname; now offers Btrfs
   quota support for subvolumes. If you set up the root file system by using
   the respective &yast; proposal, it is prepared accordingly: quota groups
   (<literal>qgroup</literal>) for all subvolumes are already set up. To set a
   quota for a subvolume in the root file system, proceed as follows:
  </para>
  <procedure>
   <step>
    <para>
     Enable quota support:
    </para>
    <screen>sudo btrfs quota enable /</screen>
   </step>
   <step>
    <para>
     Get a list of subvolumes:
    </para>
    <screen>sudo btrfs subvolume list /</screen>
    <para>
     Quotas can only be set for existing subvolumes.
    </para>
   </step>
   <step>
    <para>
     Set a quota for one of the subvolumes that was listed in the previous
     step. A subvolume can either be identified by path (for example
     <filename>/var/tmp</filename>) or by
     <literal>0/<replaceable>subvolume id</replaceable></literal> (for
     example <literal>0/272</literal>). The following example sets a quota
     of five GB for <filename>/var/tmp</filename>.
    </para>
    <screen>sudo btrfs qgroup limit 5G /var/tmp</screen>
    <para>
     The size can either be specified in bytes (5000000000), kilobytes
     (5000000K), megabytes (5000M), or gigabytes (5G). The resulting
     values in bytes slightly differ, since 1024 Bytes = 1 KiB, 1024 KiB =
     1 MiB, etc.
    </para>
   </step>
   <step>
    <para>
     To list the existing quotas, use the following command. The column
     <literal>max_rfer</literal> shows the quota in bytes.
    </para>
    <screen>sudo btrfs qgroup show -r /</screen>
   </step>
  </procedure>
  <tip>
   <title>Nullifying a Quota</title>
   <para>
    In case you want to nullify an existing quota, set a quota size of
    <literal>none</literal>:
   </para>
   <screen>sudo btrfs qgroup limit none /var/tmp</screen>
   <para>
    To disable quota support for a partition and all its subvolumes, use
    <command>btrfs quota disable</command>:
   </para>
   <screen>sudo btrfs quota disable /</screen>
  </tip>
  <para>
   See the <command>man 8 btrfs-qgroup</command> and <command>man 8
   btrfs-quota</command> for more details. The
   <citetitle>UseCases</citetitle> page on the Btrfs wiki
   (<link xlink:href="https://btrfs.wiki.kernel.org/index.php/UseCases"/>)
   also provides more information.
  </para>
 </sect1>

 <sect1 xml:id="sec.filesystems.major.btrfs.s-r">
  <!--
* https://btrfs.wiki.kernel.org/index.php/Incremental_Backup
* https://www.reddit.com/r/linux/comments/2e2iv0/confused_about_btrfs_incremental_remote_backups/
* https://github.com/openSUSE/snapper/issues/148
* https://docs.oracle.com/cd/E37670_01/E37355/html/ol_sendrecv_btrfs.html
* https://forum.rockstor.com/t/using-btrfs-send-receieve-for-backups/1342
* https://github.com/lordsutch/btrfs-backup
* https://btrfs.wiki.kernel.org/index.php/Design_notes_on_Send/Receive
* https://unix.stackexchange.com/questions/126019/how-to-use-btrfs-send-receive-for-transmitting-backup-snapshots-over-a-slow-and
* http://marc.merlins.org/perso/btrfs/post_2014-03-22_Btrfs-Tips_-Doing-Fast-Incremental-Backups-With-Btrfs-Send-and-Receive.html
* https://lwn.net/Articles/506244/
  -->
  <title>Btrfs send/receive</title>
  <para>
   Btrfs allows to make snapshots of to capture the state of the
   file system. Snapper, for example, uses this feature to create snapshots
   before and after system changes, allowing a roll-back. However, together
   with the send/recieve feature, snapshots can also be used to create and
   maintain copies of a filesystem in a remote location. This feature can,
   for example, be used to do incremental backups.
  </para>
  <para>
   A <command>btrfs send</command> operation calculates the difference between
   two read-only snapshots from the same subvolume and sends it to a file or to
   STDOUT. A <command>Btrfs receive</command> operation takes the result of the
   send command and applies it to a snapshot.
  </para>
  <sect2 xml:id="sec.filesystems.major.btrfs.s-r.requires">
   <title>Prerequisites</title>
   <para>
    To use Btrfs' send/receive feature, the following requirements need to be
    met:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      A Btrfs file system is required on the source side
      (<literal>send</literal>) and on the target side
      (<literal>receive</literal>).
     </para>
    </listitem>
    <listitem>
     <para>
      Btrfs send/receive operates on snapshots, therefore the respective data
      needs to reside in a Btrfs subvolume.
     </para>
    </listitem>
    <listitem>
     <para>
      Snapshots on the source side need to be read-only.
     </para>
    </listitem>
    <listitem>
     <para>
      &sle; 12 SP2 or better. Earlier versions of &sle; do not support
      send/receive.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>
  <sect2 xml:id="sec.filesystems.major.btrfs.s-r.backup">
   <title>Incremental Backups</title>
   <para>
    The following procedure shows the basic usage of Btrfs send/receive using
    the example of creating incremental backups of <filename>/data</filename>
    (source side) in <filename>/backup/data</filename> (target
    side). <filename>/data</filename> needs to be a subvolume.
   </para>

   <procedure>
    <title>Initial Setup</title>
    <step>
     <para>
      Create the initial snapshot, (called <literal>snapshot_0</literal> in
      this example) on the source side and make sure it is written to the disk:
     </para>
     <screen>sudo btrfs subvolume snapshot -r /data /data/bkp_data
sync</screen>
     <para>
      A new subvolume <filename>/data/bkp_data</filename> is created. It
      will be used as the basis for the next incremental backup and should be
      kept as a reference.
     </para>
    </step>
    <step>
     <para>
      Send the initial snapshot to the target side. Since this is the initial
      snd/receive operation, the complete snapshot needs to be sent:
     </para>
     <screen>sudo bash -c 'btrfs send /data/bkp_data | btrfs receive /backup</screen>
     <para>
      A new subvolume <filename>/backup/bkp_data</filename> is created on the
      target side.
     </para>
    </step>
   </procedure>

   <para>
    Once the initial setup has been finished, you can create incremental
    backups and send the differences between the current and the previous
    snapshots to the target side. THe procedure is always the same:
   </para>
   <orderedlist>
    <listitem>
     <para>
      Create a new snapshot on the source side.
     </para>
    </listitem>
    <listitem>
     <para>
      Send the differences to the target side.
     </para>
    </listitem>
    <listitem>
     <para>
      Optional: Rename and/or clean up snapshots on both sides.
     </para>
    </listitem>
   </orderedlist>

   <procedure>
    <title>Performing an Incremental Backup</title>
    <step>
     <para>
      Create a new snapshot on the source side and make sure it is written to
      the disk. In the following example the snapshot is named
      bkp_data_<replaceable>CURRENT_DATE</replaceable>:
     </para>
     <screen>sudo btrfs subvolume snapshot -r /data /data/bkp_data_$(date +%F)
sync</screen>
     <para>
      A new subvolume <filename>/data/bkp_data_2016-07-07</filename>
      is created.
     </para>
    </step>
    <step>
     <para>
      Send the difference between the previous snapshot and the one you have
      just created to the target side. This is achieved by specifying the
      previous snapshot with the option <option>-p
      <replaceable>snapshot</replaceable></option>.
     </para>
     <screen>sudo bash -c 'btrfs send -p /data/bkp_data /data/bkp_data_2016-07-07 \
| btrfs receive /backup</screen>
     <para>
      A new subvolume <filename>/backup/bkp_data_2016-07-07</filename>
      is created.
     </para>
    </step>
    <step>
     <para>
      As a result four snapshots, two on each side, now exist:
     </para>
     <simplelist>
      <member><filename>/data/bkp_data</filename></member>
      <member><filename>/data/bkp_data_2016-07-07</filename></member>
      <member><filename>/backup/bkp_data</filename></member>
      <member><filename>/backup/bkp_data_2016-07-07</filename></member>
     </simplelist>
     <para>
      Now you have three options how to proceed.
     </para>
     <itemizedlist>
      <listitem>
       <para>
        Keep all snapshots on both sides. With this option you can roll back to
        any snapshot on both sides while having all data duplicated at the same
        time. No further action is required. When doing the next incremental
        backup, keep in mind to use the next-to-last snapshot as parent for the
        send operation.
       </para>
      </listitem>
      <listitem>
       <para>
        Only keep the last snapshot on the source side and all snapshots on the
        target side. Also allows to roll back to any snapshot on both
        sides&mdash;to do a rollback to a specific snapshot on the source side,
        perform a send/receive operation of a complete snapshot from the target
        side to the source side. Da a delete/move operation on the source side.
       </para>
      </listitem>
      <listitem>
       <para>
        Only keep tha last snapshot on both sides. This way you have a backup
        on the target side that represents the state of the last snapshot made
        on the source side. It is not possible to roll back to other
        snapshots. Da a delete/move operation on the source and the target
        side.
       </para>
      </listitem>
     </itemizedlist>
     <substeps>
      <step>
       <para>
        To only keep the last snapshot on the source side, perform the
        following commands:
       </para>
       <screen>sudo btrfs subvolume delete /data/bkp_data
sudo mv /data/bkp_data_2016-07-07 /data/bkp_data</screen>
       <para>
        The first command will delete the previous snapshot, the second command
        renames the current snapshot to
        <filename>/data/bkp_data</filename>. This ensures that the last
        snapshot that was backed up is always named
        <filename>/data/bkp_data</filename>. As a consequence, you can also
        always use this subvolume name as a parent for the incremental send
        operation.
       </para>
      </step>
      <step>
       <para>
        To only keep the last snapshot on the target side, perform the
        following commands:
       </para>
       <screen>sudo btrfs subvolume delete /backup/bkp_data
sudo mv /backup/bkp_data_2016-07-07 /backup/bkp_data
       </screen>
       <para>
        The first command will delete the previous backup snapshot, the second
        command renames the current backup snapshot to
        <filename>/backup/bkp_data</filename>. This ensures that the latest
        backup snapshot is always named <filename>/backup/bkp_data</filename>.
       </para>
      </step>
     </substeps>
    </step>
   </procedure>

   <tip>
    <title>Sending to a Remote Target Side</title>
    <para>
     To send the snapshots to a remote machine, use SSH:
    </para>
    <screen>btrfs send /data/bkp_data | ssh root@&wsIname; 'btrfs receive /backup'</screen>
   </tip>
  </sect2>
 </sect1>

 <sect1 xml:id="sec.filesystems.major.btrfs.deduplication">
  <title>Data Deduplication Support</title>
  <para>
   Btrfs supports data deduplication by replacing identical blocks in the
   file system with logical links to a single copy of the block in a
   common storage location. &productname; provides the tool
   <command>duperemove</command> for scanning the file system for
   identical blocks. When used on a Btrfs file system, it can also be used
   to deduplicate these blocks. duperemove is not installed by default. To
   make it available, install the package
   <systemitem class="resource">duperemove</systemitem>.
  </para>
  <note>
   <title>Use Cases</title>
   <para>
    As of &productname; &productnumber; duperemove is not suited to
    deduplicate the entire file system. It is intended to be used to
    deduplicate a set of 10 to 50 large files that possibly have lots of
    blocks in common, such as virtual machine images.
   </para>
  </note>
  <para>
   <command>duperemove</command> can either operate on a list of files or
   recursively scan a directory:
  </para>
  <screen>sudo duperemove <replaceable>[options]</replaceable> file1 file2 file3
sudo duperemove -r <replaceable>[options]</replaceable> directory</screen>
  <para>
   It operates in two modes: read-only and de-duping. When run in
   read-only mode (that is without the <option>-d</option> switch), it
   scans the given files or directories for duplicated blocks and prints
   them out. This works on any file system.
  </para>
  <para>
   Running <command>duperemove</command> in de-duping mode is only
   supported on Btrfs file systems. After having scanned the given files
   or directories, the duplicated blocks will be submitted for
   deduplication.
  </para>
  <para>
   For more information see <command>man 8 duperemove</command>.
  </para>
 </sect1>
 <sect1 xml:id="sect.btrfs.trouble">
  <title>Troubleshooting Btrfs</title>

  <para>
   This section describes some known issues and possible solutions for the
   Btrfs file system.
  </para>

  <sect2 xml:id="sect.filesystems.trouble.btrfs_volfull">
   <title>Btrfs Error: No space is left on device</title>
   <para>
    The root (<filename>/</filename>) partition using the Btrfs file system
    stops accepting data. You receive the error <quote><literal>No space
    left on device</literal></quote>.
   </para>
   <para>
    See the following sections for information about possible causes and
    prevention of this issue.
   </para>
   <sect3 xml:id="sect.filesystems.trouble.btrfs_volfull.snapshots">
    <title>Disk Space Consumed by Snapper Snapshots</title>
    <para>
     If Snapper is running for the Btrfs file system, the <quote><literal>No
     space left on device</literal></quote> problem is typically caused by
     having too much data stored as snapshots on your system.
    </para>
    <para>
     You can remove some snapshots from Snapper, however, the snapshots are
     not deleted immediately and might not free up as much space as you
     need.
    </para>
    <para>
     To delete files from Snapper:
    </para>
    <procedure>
     <step>
      <para>
       Open a terminal console.
      </para>
     </step>
     <step>
      <para>
       At the command prompt, enter <command>btrfs filesystem
       show</command>, for example:
      </para>
<screen>&prompt.user;sudo btrfs filesystem show
Label: none uuid: 40123456-cb2c-4678-8b3d-d014d1c78c78
 Total devices 1 FS bytes used 20.00GB
 devid 1 size 20.00GB used 20.00GB path /dev/sda3</screen>
     </step>
     <step>
      <para>
       Enter
      </para>
<screen>sudo btrfs fi balance start <replaceable>mountpoint</replaceable> -dusage=5</screen>
      <para>
       This command attempts to relocate data in empty or near-empty data
       chunks, allowing the space to be reclaimed and reassigned to
       metadata. This can take a while (many hours for 1 TB) although the
       system is otherwise usable during this time.
      </para>
     </step>
     <step>
      <para>
       List the snapshots in Snapper. Enter
      </para>
<screen>sudo snapper -c root list</screen>
     </step>
     <step>
      <para>
       Delete one or more snapshots from Snapper. Enter
      </para>
<screen>sudo snapper -c root delete <replaceable>snapshot_number(s)</replaceable></screen>
      <para>
       Ensure that you delete the oldest snapshots first. The older a
       snapshot is, the more disk space it occupies.
      </para>
     </step>
    </procedure>
    <para>
     To help prevent this problem, you can change the Snapper cleanup
     algorithms. See <xref linkend="sec.snapper.manage.metadata.cleanup"/>
     for details. The configuration values controlling snapshot cleanup are
     <envar>EMPTY_*</envar>, <envar>NUMBER_*</envar>, and
     <envar>TIMELINE_*</envar>.
    </para>
    <para>
     If you use Snapper with Btrfs on the file system disk, it is advisable
     to reserve twice the amount of disk space than the standard storage
     proposal. The &yast; Partitioner automatically proposes twice the
     standard disk space in the Btrfs storage proposal for the root file
     system.
    </para>
   </sect3>
   <sect3 xml:id="sect.filesystems.trouble.btrfs_volfull.var">
    <title>Disk Space Consumed by Log, Crash, and Cache Files</title>
    <para>
     If the system disk is filling up with data, you can try deleting files
     from <filename>/var/log</filename>, <filename>/var/crash</filename>,
     and <filename>/var/cache</filename>.
    </para>
    <para>
     The Btrfs &rootuser; file system subvolumes
     <filename>/var/log</filename>, <filename>/var/crash</filename> and
     <filename>/var/cache</filename> can use all of the available disk space
     during normal operation, and cause a system malfunction. To help avoid
     this situation, &productname; offers Btrfs quota support for
     subvolumes. See <xref linkend="sec.filesystems.major.btrfs.quota"/> for
     details.
    </para>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec_filesystems_info">
  <title>Additional Information</title>

  <para>
   Each of the file system projects described above maintains its own home
   page on which to find mailing list information, further documentation,
   and FAQs:
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     The Btrfs Wiki on Kernel.org:
     <link xlink:href="https://btrfs.wiki.kernel.org/"/>
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
