<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
  %entities;
]>

<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         version="5.0" xml:id="cha-tuning-cgroups">

 <title>Kernel Control Groups</title>
 <info>
  <abstract>
   <para>
    Kernel Control Groups (<quote>cgroups</quote>) are a kernel feature
    that allows assigning and limiting hardware and system resources for processes.
    Processes can also be organized in a hierarchical tree structure.
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker>
   </dm:bugtracker>
  </dm:docmanager>
 </info>

 <sect1 xml:id="sec-tuning-cgroups-overview">
  <title>Overview</title>
  <para>
   Every process is assigned exactly one administrative cgroup. cgroups are ordered
   in a hierarchical tree structure. You can set resource limitations, such as
   CPU, memory, disk I/O, or network bandwidth usage,for single processes or for 
   whole branches of the hierarchy tree.
  </para>
  <para>
   On &productname;, &systemd; uses cgroups to organize all
   processes in groups, which &systemd; calls slices. &systemd; also
   provides an interface for setting cgroup properties.
  </para>
  <para>
   The command <command>systemd-cgls</command> displays the hierarchy
   tree.
  </para>
  <para>
   This chapter is an overview. For more details, refer to the listed
   references.
  </para>
 </sect1>

 <sect1 xml:id="sec-tuning-cgroups-usage">
  <title>Setting Resource Limits</title>
  <note>
    <title>Implicit Resource Consumption</title>
    <para>
      Be aware that resource consumption implicitly depends on the environment
      where your workload executes (e.g. size of data structures in libraries/kernel,
      forking behavior of utilities, computational efficiency),
      hence it is recommended to (re)calibrate your limits should the environment change.
    </para>
  </note>
  <para>
   Limitations to <literal>cgroups</literal> can be set with the
   <command>systemctl set-property</command> command. The syntax is:
  </para>
  <screen>&prompt.root;<command>systemctl set-property [--runtime] <replaceable>NAME</replaceable> <replaceable>PROPERTY1</replaceable>=<replaceable>VALUE</replaceable> [<replaceable>PROPERTY2</replaceable>=<replaceable>VALUE</replaceable>]</command></screen>
  <para>
   Optionally, use the <option>--runtime</option> option. With this
   option, set limits do not persist after the next reboot.
  </para>
  <para>
   Replace <replaceable>NAME</replaceable> with a &systemd; service
   slice, scope, socket, mount, or swap name. Replace properties with
   one or more of the following:
  </para>
  <variablelist>
   <varlistentry>
    <term><literal>CPUAccounting=</literal><option>[yes|no]</option></term>
    <listitem>
     <para>
      Turns on CPU usage accounting. This property takes
      <literal>yes</literal> and <literal>no</literal> as arguments.
     </para>
     <para>
      Example:
     </para>
     <screen>&prompt.root;<command>systemctl set-property user.slice CPUAccounting=yes</command></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>CPUQuota=</literal><replaceable>PERCENTAGE</replaceable></term>
    <listitem>
     <para>
      Assigns a CPU time to processes. The value is a percentage
      followed by a <literal>%</literal> as suffix. This implies
      <literal>CPUAccounting=yes</literal>.
     </para>
     <para>
      Example:
     </para>
     <screen>&prompt.root;<command>systemctl set-property user.slice CPUQuota=50%</command></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>MemoryAccounting=</literal><option>[yes|no]</option></term>
    <listitem>
     <para>
      Turns on memory usage accounting. This property takes
      <literal>yes</literal> and <literal>no</literal> as arguments.
     </para>
     <para>
      Example:
     </para>
     <screen>&prompt.root;<command>systemctl set-property user.slice MemoryAccounting=yes</command></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>MemoryLow=</literal><replaceable>BYTES</replaceable></term>
    <listitem>
     <para>
      Unused memory from processes below this limit will not be
      reclaimed for other use. Use suffixes K, M, G or T for
      <replaceable>BYTES</replaceable>. This implies
      <literal>MemoryAccounting=yes</literal>.
     </para>
     <para>
      Example:
     </para>
     <screen>&prompt.root;<command>systemctl set-property nginx.service MemoryLow=512M</command></screen>
     <note>
      <title>Unified Control Group Hierarchy</title>
      <para>
       This setting is available only if the unified control group hierarchy is
       used, and disables <option>MemoryLimit=</option>. To enable the unified
       control group hierarchy, append
       <option>systemd.unified_cgroup_hierarchy=1</option> as a kernel command
       line parameter to the &grub; boot loader. Refer to <xref
        linkend="cha-grub2"/> for more details about configuring &grub;.
      </para>
     </note>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>MemoryHigh=</literal><replaceable>BYTES</replaceable></term>
    <listitem>
     <para>
      If more memory above this limit is used, memory is aggressively
      taken away from the processes. Use suffixes K, M, G or T for
      <replaceable>BYTES</replaceable>. This implies
      <literal>MemoryAccounting=yes</literal>.
     </para>

     <para>
      Example:
     </para>
     <screen>&prompt.root;<command>systemctl set-property nginx.service MemoryHigh=2G</command></screen>
     <note>
      <title>Unified Control Group Hierarchy</title>
      <para>
       This setting is available only if the unified control group hierarchy is
       used, and disables <option>MemoryLimit=</option>. To enable the unified
       control group hierarchy, append
       <option>systemd.unified_cgroup_hierarchy=1</option> as a kernel command
       line parameter to the &grub; boot loader. Refer to <xref
        linkend="cha-grub2"/> for more details about configuring &grub;.
      </para>
     </note>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>MemoryMax=</literal><replaceable>BYTES</replaceable></term>
    <listitem>
     <para>
      Sets a maximum limit for used memory. Processes will be killed if
      they use more memory than allowed. Use suffixes K, M, G or T for
      <replaceable>BYTES</replaceable>. This implies
      <literal>MemoryAccounting=yes</literal>.
     </para>
     <para>
      Example:
     </para>
     <screen>&prompt.root;<command>systemctl set-property nginx.service MemoryMax=4G</command></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>DeviceAllow=</literal></term>
    <listitem>
     <para>
      Allows read (<literal>r</literal>), write (<literal>w</literal>)
      and mknod (<literal>m</literal>) access. The command takes a
      device node specifier and a list of <literal>r</literal>, <literal>w</literal> or
      <literal>m</literal>, separated by a white space.
     </para>
     <para>
      Example:
     </para>
     <screen>&prompt.root;<command>systemctl set-property system.slice DeviceAllow="/dev/sdb1 r"</command></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>DevicePolicy=</literal><option>[auto|closed|strict]</option></term>
    <listitem>
     <para>
      When set to <literal>strict</literal>, only access to devices
      that are listed in <literal>DeviceAllow</literal> is allowed.
      <literal>closed</literal> additionally allows access to standard
      pseudo devices including <filename>/dev/null</filename>,
      <filename>/dev/zero</filename>, <filename>/dev/full</filename>,
      <filename>/dev/random</filename>, and
      <filename>/dev/urandom</filename>.
      <literal>auto</literal> allows access to all devices if no
      specific rule is defined in <literal>DeviceAllow</literal>.
      <literal>auto</literal> is the default setting.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
  <para>
   For more details and a complete list of properties, see <command>man
   systemd.resource-control</command>.
  </para>
 </sect1>
 
 <sect1 xml:id="sec-tuning-cgroups-tasksmax">
  <title>Preventing Fork Bombs with TasksMax</title>
  <para>
      &systemd; 228 shipped with a <literal>DefaultTasksMax</literal> 
      limit of 512, which is set in 
      <filename>/etc/systemd/system.conf</filename>. This limits the
      number of tasks any &systemd; unit can create at one time to
      512. Previous versions had no default limit. The goal was to
      improve security by preventing runaway processes from creating
      excessive forks, or spawning enough threads to exhaust
      system resources.
  </para>
  <para>
      However, it soon became apparent that there is not a single
      default that applies to all use cases. 512 is not low enough
      to prevent a runaway process from crashing a system, and not
      high enough for processes that create a lot of threads, such
      as databases. In &systemd; 234 the default was changed to 15%, 
      which is 4915 tasks (15% of the kernel limit of 32768, 
      see <command>cat /proc/sys/kernel/pid_max</command>).
  </para>
  <para>
      &sle; ships with a custom configuration that overrides the upstream
      default. 
      <filename>/usr/lib/systemd/system.conf.d/20-suse-defaults.conf</filename>
      overrides the default limit with the following configuration:
  </para>
  <screen>
[Manager]
DefaultTasksMax=infinity
  </screen>
  <para>
      When you query the value with <command>systemctl</command> it looks like
      this:
  </para>
  <screen>&prompt.user;systemctl show --property DefaultTasksMax
DefaultTasksMax=18446744073709551615</screen>
  <para>
       This is the same as having no limit. It is not a requirement to change the 
       default, but setting some limits may help to prevent system crashes
       from runaway processes.
   </para>
   <para>
       Change the global default in
       <filename>/etc/systemd/system.conf</filename> by uncommenting the 
       <literal>DefaultTasksMax</literal> line, and changing the value either
       to a number of tasks, or a percentage, like the following examples:
   </para>
   <screen>DefaultTasksMax=128
DefaultTasksMax=7%
</screen>
   <para>
       Load the new setting, then verify that it changed:
   </para>
   <screen>&prompt.sudo;systemctl daemon-reload
&prompt.user;systemctl show --property DefaultTasksMax
DefaultTasksMax=128
   </screen>
   <para>
       Now you can set higher limits on individual services as needed. This
       example is for MariaDB. <command>systemctl</command> has at least two
       ways of checking the current value:
   </para>
   <screen>&prompt.user;systemctl show -p TasksMax mariadb.service
TasksMax=128

&prompt.user;systemctl status mariadb.service
  ● mariadb.service - MariaDB database server
   Loaded: loaded (/usr/lib/systemd/system/mariadb.service; disabled; vendor pr>
   Active: active (running) since Tue 2020-05-26 14:15:03 PDT; 27min ago
     Docs: man:mysqld(8)
           https://mariadb.com/kb/en/library/systemd/
 Main PID: 11845 (mysqld)
   Status: "Taking your SQL requests now..."
    Tasks: 30 (limit: 128)
   CGroup: /system.slice/mariadb.service
           └─11845 /usr/sbin/mysqld --defaults-file=/etc/my.cnf --user=mysql
   </screen>
   <para>
       The Tasks line shows that MariaDB currently has 30 tasks running, and
       an upper limit of 128. The following example demonstrates how to raise
       MariaDB's limit to 1024:
   </para>
   <screen>
&prompt.sudo;systemctl edit --system mariadb.service
[System]
TasksMax=1024
</screen>
   <para>
       This creates an override file, 
       <filename>/etc/systemd/system/mariadb.service.d/override.conf</filename>.
       If you prefer to edit the full service file, use the 
       <command>--full</command> option:
   </para>
   <screen>&prompt.sudo;systemctl edit --system --full mariadb.service</screen>
   <para>    
       Then load the new value:
   </para>
   <screen>&prompt.sudo;systemctl daemon-reload</screen>
   <para>
       You may also wish to set custom values for user processes. The &sle; default
       for user slices is also infinity, set in
       <filename>/usr/lib/systemd/system/user-.slice.d/20-suse-defaults.conf</filename>.
       Verify this the same way as for system services:
   </para>
   <screen>&prompt.user;systemctl show -p TasksMax user-1000.slice
TasksMax=18446744073709551615
   </screen>
   <para>
       Change this for <literal>user-1000.slice</literal> to 256:
   </para>
   <screen>&prompt.sudo;systemctl edit user@1001.service
[Service]
TasksMax=256
   </screen>
   <para>
       The new value takes effect at the next user login. For more information
       see systemd.resource-control(5).   
   </para>   
</sect1>

<sect1>
    <title>For More Information</title>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     Kernel documentation (package <systemitem>kernel-source</systemitem>):
     files in <filename>/usr/src/linux/Documentation/cgroups</filename>.
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://lwn.net/Articles/604609/"/>&mdash;Brown,
     Neil: Control Groups Series (2014, 7 parts).
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://lwn.net/Articles/243795/"/>&mdash;Corbet,
     Jonathan: Controlling memory use in containers (2007).
    </para>
   </listitem>
   <listitem>
    <para>
     <link xlink:href="http://lwn.net/Articles/236038/"/>&mdash;Corbet,
     Jonathan: Process containers (2007).
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
</chapter>
