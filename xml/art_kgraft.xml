<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="urn:x-suse:xslt:profiling:novdoc-profile.xsl"
                 type="text/xml"
                 title="Profiling step"?>
<!DOCTYPE article PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd"
[
<!ENTITY % NOVDOC.DEACTIVATE.IDREF "INCLUDE">
<!ENTITY % entities SYSTEM "entity-decl.ent">
%entities;
]>
<?provo dirname="kgraft/"?>
<article id="art.kgraft" lang="en">
<?suse-quickstart color="suse"?>
 <title>Live Kernel Patching Using &kg;</title>
 <subtitle>&productname; &productnumber;</subtitle>
 <articleinfo><productname>&productname;</productname>
  <productnumber>&productnumber;</productnumber>
 </articleinfo>
 <abstract>
  <para>
   This document describes the basic principles of the &kg; live patching technology.
  </para>
  <para>
   &kg; is a live patching technology for run-time patching of the Linux kernel, without
   stopping the kernel. This maximizes system uptime, and thus system availability, which
   is important for mission critical systems. By allowing dynamic patching of the kernel,
   the technology also encourages users to install critical security updates without
   deferring them to a scheduled downtime.
  </para>
  <para>
   A &kg; patch is a kernel module, intended for replacing whole functions
   in the kernel. &kg; offers tools for creating the live patch modules and
   integrating them with kernel code at runtime.
  </para>
 </abstract>

<sect1>
  <title>Advantages of &kg;</title>
  <para>
   Live kernel patching using &kg; is especially useful for quick response in
   emergencies (when serious vulnerabilities are known and should be fixed as
   soon as possible or when the systems are already actively exploited). It is
   not used for scheduled updates where time is not critical.
  </para>
  <para>
   The main advantage of &kg; is that it never requires stopping the kernel,
   not even for a short time period like competing technologies.
  </para>
  <para>
   A &kg; patch is a <filename>.ko</filename> kernel module in a KMP RPM
   package. It is inserted into the kernel using <command>insmod</command>
   command when the RPM package is installed or updated. &kg; replaces whole
   functions in the kernel, even if they are being executed. An updated &kg;
   module can replace an existing patch if necessary.
  </para>
  <para>
   &kg; is also lean, it contains only a small amount of code, because it
   leverages other standard Linux technologies.
  </para>
</sect1>
<sect1>
 <title>Low-level Function of &kg;</title>
 <para>
  &kg; uses the ftrace infrastructure to perform patching. To patch a kernel
  function, &kg; needs some space at the start of the function to insert a
  jump to a new function. The space is provided by GCC profiling.
 </para>
 <para>
  At boot, fentry call instructions are replaced by 5-byte NOP (no operation)
  instructions. After patching starts, the first byte is replaced by the INT3
  isntruction and the remaining four bytes are replaced by the address to the
  new function. Then the first byte is replaced by the JMP (long jump)
  instruction. Inter-processor non-maskable interrupts (IPI NMI) are used
  throughout the process to flush speculative decoding queues of other CPUs in
  the system. This allows switching to the new function without ever stopping
  the kernel, not even for a very short moment. The interruptions by IPI NMIs
  can be measured in microseconds.
 </para>
 <para>
  Callers are never patched, instead, callee's NOPs are replaced by a JMP to
  the new function. JMP instructions remain forever. This takes care of
  function pointers, including in structures, and does not require saving any
  old data for possibility of un-patching.
 </para>
 <para>
  However, these steps alone would not be good enough: since the functions
  would be replaced non-atomically, a new fixed function in one part of the
  kernel could still be calling an old function elsewhere or vice versa. If
  the semantics of the function interfaces changed in the patch, chaos would
  ensue.
 </para>
 <para>
  Thus, until all functions are replaced, &kg; uses an approach based on
  trampolines and similar to RCU (read-copy-update), to ensure a consistent
  view of the world to each userspace thread, kernel thread or kernel
  interrupt. A per-thread flag is set on each kernel entry and exit.
  This way, an old function always would call another old function
  and a new function always a new one. Once all processes have the "new
  universe" flag set patching is complete, trampolines can be removed
  and the code can operate at full speed without performance impact other
  than an extra long jump for each patched function.
 </para>
</sect1>
<sect1>
 <title>Installing &kg; Patches</title>
 <para>
  To aplly a &kg; patch, follow these steps:
 </para>
 <procedure>
  <step>
   <para>
    Using <command>zypper</command>, install the &kg; patch from
    &kg; channel. Choose the appropriate patch for your kernel
    version (<filename>-default</filename> or <filename>-xen</filename>).
   </para>
   <para>
    When installing the first patch, the <systemitem>kgraft</systemitem>
    package with the necessary &kg; scripts is also installed.
   </para>
   <!--FIXME name of the channel?-->
  </step>
  <step>
   <para>
    The kernel is patched automatically after the package installation.
    However, the old kernel functions are not completely removed until
    all sleeping processes wake up and get out of the way. This can
    take a considerable amount of time. Sleeping processes using the
    old kernel functions are not considered a security issue, however,
    in the current version of &kg;, it is not possible to apply another
    &kg; patch until the previous patch is completely finished.
   </para>
   <para>
    First, check the global flag in
    <filename>/sys/kernel/kgraft/in_progress</filename>. The value
    <literal>1</literal> signifies existing sleeping processes that still need
    an update (the patching is still in progress), the value
    <literal>0</literal> signifies that the patch was completely finished.
    Alternatively, use the <command>kgr status</command> command.
   </para>
   <para>
    To get a list of all sleeping processes, check the number in
    <filename>/proc/<replaceable>process_number</replaceable>/kgr_in_progress</filename>
    for each process. The value <literal>1</literal> signifies sleeping
    process that still needs an update. Alternatively, use the <command>kgr
     blocking</command> command to output the list of sleeping processes.
   </para>
  </step>
  <step>
   <para>
    It is up to the system administrator to decide how to deal with
    the sleeping processes. One possibility is to wait, another
    possibility is to send a SIGSTOP signal followed by a SIGCONT
    signal to all the sleeping processes. It can be achieved easily
    using the <command>kgr poke</command> command.
   </para>
  </step>
 </procedure>
</sect1>
<sect1>
  <title>Removing a &kg; Patch</title>
  <para>
   Due to the way zypper operates, it is not sufficient to simply remove a
   &kg; patch with zypper. Rebuilding initrd and rebooting is required:
  </para>
  <procedure>
   <step>
   <para>
    First remove the patch itself using zypper:
   </para>
   <screen>
    zypper rm kgraft-patch-default
   </screen>
  </step>
  <step>
   <para>
    Rebuild the initrd:
   </para>
   <screen>
    mkinitrd
   </screen>
  </step>
  <step>
   <para>
    Reboot the machine.
   </para>
  </step>
  </procedure>
</sect1>
<sect1>
 <title>The <command>kgr</command> Tool</title>
  <para>
   Several &kg; management tasks can be simplified
   with the <command>kgr</command> tool. The available commands are:
  </para>
  <variablelist>
   <varlistentry>
    <term><command>kgr status</command></term>
    <listitem>
     <para>
      Displays the overall status of &kg; patching (<literal>ready</literal> or
      <literal>in_progress</literal>). It takes the information from
      <filename>/sys/kernel/kgraft/in_progress</filename>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>kgr patches</command></term>
    <listitem>
     <para>
      Displays the list of loaded &kg; patches.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>kgr blocking</command></term>
    <listitem>
     <para>
      Lists processes that are preventing &kg; patching from finishing. By
      default just the PIDs are listed. Specifying <option>-v</option> prints
      out command lines. Another <option>-v</option> displays also strack
      traces.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>kgr poke</command></term>
    <listitem>
     <para>
      Sends SIGSTOP and SIGCONT to all processess that are blocking &kg; patching from finishing.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
  <para>
   For detailed information, see <command>man kgr</command>.
  </para>
</sect1>
<sect1>
 <title>Limitations of &kg;</title>
 <para>
  &kg; has also some technical limitations. &kg; only replaces functions, not data.
  Changes in kernel data structure require special care and, if the change is too
  large, rebooting might be required. &kg; also doesn't specifically handle situations
  where one compiler is used to compile the old kernel and another compiler is used
  for compiling the patch.
 </para>
 <para>
  Sending SIGSTOP and SIGCONT signals to processes in D process state
  (uninterruptible sleep) does not make them to cross the kernel/user space
  boundary and does not have the intended effect. Also, kernel threads by
  definition do leave the kernel space and the &kg; patching must be supported
  at the code level. Support for third-party modules is therefore limited.
 </para>
 <para>
  Only CVSS (Common Vulnerability Scoring System) level 6+ vulnerabilities
  related to system stability or data corruption will be patched using &kg;.
  For more information on CVSS, see <ulink url="http://nvd.nist.gov/cvss.cfm/" />.
  <!--kernelové thready, EAL6+ stability fixes, data loss-->
 </para>
</sect1>
</article>
