<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="urn:x-suse:xslt:profiling:novdoc-profile.xsl"
                 type="text/xml"
                 title="Profiling step"?>
<!DOCTYPE article PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd"
[
<!ENTITY % NOVDOC.DEACTIVATE.IDREF "INCLUDE">
<!ENTITY % entities SYSTEM "entity-decl.ent">
%entities;
]>
<?provo dirname="kgraft/"?>
<article id="art.kgraft" lang="en">
<?suse-quickstart color="suse"?>
 <title>Live Kernel Patching Using &kg;</title>
 <subtitle>&productname; &productnumber;</subtitle>
 <articleinfo><productname>&productname;</productname>
  <productnumber>&productnumber;</productnumber>
 </articleinfo>
 <abstract>
  <para>
   This document describes the basic principles of the &kg; live patching
   technology and provides usage guidelines for the SLE Live Patching service.
  </para>
  <para>
   &kg; is a live patching technology for run-time patching of the Linux kernel, without
   stopping the kernel. This maximizes system uptime, and thus system availability, which
   is important for mission critical systems. By allowing dynamic patching of the kernel,
   the technology also encourages users to install critical security updates without
   deferring them to a scheduled downtime.
  </para>
  <para>
   Typical use cases for &kg; include systems like memory databases with huge
   amounts of RAM, where bootup times of 15 minutes or more are no exception,
   large simulations that need weeks or months without a restart, or
   infrastructure building blocks providing continuous service to large
   number of consumers.
  </para>
  <para>
   A &kg; patch is a kernel module, intended for replacing whole functions
   in the kernel. &kg; primarily offers in-kernel infrastructure for
   integration of the patched code with base kernel code at runtime.
  </para>
  <para>
   SLE Live Patching is a service provided on top of regular SUSE Linux
   Enterprise Server maintenance.  &kg; patches distributed through SLE Live
   Patching supplement regular SLES maintenance updates.  Common update stack
   and procedures can be used for SLE Live Patching deployment.
  </para>
 </abstract>

<sect1>
  <title>Advantages of &kg;</title>
  <para>
   Live kernel patching using &kg; is especially useful for quick response in
   emergencies (when serious vulnerabilities are known and should be fixed as
   soon as possible or when the system is being exploited). It is not used for
   scheduled updates where time is not critical.
  </para>
  <para>
   The main advantage of &kg; is that it never requires stopping the kernel,
   not even for a short time period.
  </para>
  <para>
   A &kg; patch is a <filename>.ko</filename> kernel module in a KMP RPM
   package. It is inserted into the kernel using <command>insmod</command>
   command when the RPM package is installed or updated. &kg; replaces whole
   functions in the kernel, even if they are being executed. An updated &kg;
   module can replace an existing patch if necessary.
  </para>
  <para>
   &kg; is also lean, it contains only a small amount of code, because it
   leverages other standard Linux technologies.
  </para>
</sect1>
<sect1>
 <title>Low-level Function of &kg;</title>
 <para>
  &kg; uses the ftrace infrastructure to perform patching. The following
  describes the implementation on the x86-64 architecture.
 </para>
 <para>
  To patch a kernel function, &kg; needs some space at the start of the
  function to insert a jump to a new function. This space is allocated during
  kernel compilation by GCC with function profiling turned on. In particular,
  a 5-byte call instruction is injected to the start of kernel functions.
  When such instrumented kernel is booting, profiling calls are replaced by
  5-byte NOP (no operation) instructions.
 </para>
 <para>
  After patching starts, the first byte is replaced by the INT3 (breakpoint)
  instruction. This ensures atomicity of the 5-byte instruction replacement.
  The other four bytes are replaced by the address to the new function.
  Finally, the first byte is replaced by the JMP (long jump) opcode.
 </para>
 <para>
  Inter-processor non-maskable interrupts (IPI NMI) are used throughout the
  process to flush speculative decoding queues of other CPUs in the system.
  This allows switching to the new function without ever stopping the kernel,
  not even for a very short moment. The interruptions by IPI NMIs can be
  measured in microseconds and are not considered service interruption as they
  happen while the kernel is running in any case.
 </para>
 <para><!--FIXME-->
  Callers are never patched. Instead, callee's NOPs are replaced by a JMP to
  the new function. JMP instructions remain forever. This takes care of
  function pointers, including in structures, and does not require saving any
  old data for possibility of un-patching.
 </para>
 <para>
  However, these steps alone would not be good enough: since the functions
  would be replaced non-atomically, a new fixed function in one part of the
  kernel could still be calling an old function elsewhere or vice versa. If
  the semantics of the function interfaces changed in the patch, chaos would
  ensue.
 </para>
 <para>
  Thus, until all functions are replaced, &kg; uses an approach based on
  trampolines and similar to RCU (read-copy-update), to ensure a consistent
  view of the world to each userspace thread, kernel thread or kernel
  interrupt. A per-thread flag is set on each kernel entry and exit.
  This way, an old function always would call another old function
  and a new function always a new one. Once all processes have the "new
  universe" flag set patching is complete, trampolines can be removed
  and the code can operate at full speed without performance impact other
  than an extra long jump for each patched function.
 </para>
</sect1>
<sect1>
  <title>Installing &kg; Patches</title>
  <para>
   To activate SLE Live Patching on your system, go to YaST2 Control Center,
   select SUSE Customer Center Configuration and proceed with Select Extensions
   to activate the SLE Live Patching.  This will install the base &kg;
   components on your system together with the initial live patch.
  </para>
 <sect2>
  <title>Updating System</title>
 <procedure>
  <step>
   <para>
    SLE Live Patching updates are distributed in a form that allows using
    standard SLE update stack for patch application.  The initial live patch
    can be updated using <command>zypper patch</command>, YaST2 Online Update
    or equivalent method.
   </para>
  </step>
  <step>
   <para>
    The kernel is patched automatically during the package installation.
    However, the old kernel functions are not completely removed until
    all sleeping processes wake up and get out of the way. This can
    take a considerable amount of time. Sleeping processes using the
    old kernel functions are not considered a security issue, however,
    in the current version of &kg;, it is not possible to apply another
    &kg; patch until the previous patch is used by all processes.
   </para>
   <para>
    First, check the global flag in
    <filename>/sys/kernel/kgraft/in_progress</filename>. The value
    <literal>1</literal> signifies existing sleeping processes that still need
    an update (the patching is still in progress), the value
    <literal>0</literal> signifies that the patch is used by all processes.
    Alternatively, use the <command>kgr status</command> command.
   </para>
   <para>
    To get a list of all sleeping processes, check the number in
    <filename>/proc/<replaceable>process_number</replaceable>/kgr_in_progress</filename>
    for each process. The value <literal>1</literal> signifies sleeping
    process that still needs an update. Alternatively, use the <command>kgr
     blocking</command> command to output the list of sleeping processes.
   </para>
  </step>
  <step>
   <para>
    It is up to the system administrator to decide how to deal with
    the sleeping processes. One possibility is to wait, another
    possibility is to send a SIGSTOP signal followed by a SIGCONT
    signal to all the sleeping processes. It can be achieved easily
    using the <command>kgr poke</command> command. Running processes
    are not interrupted.
   </para>
  </step>
 </procedure>
 </sect2>
</sect1>
<sect1>
  <title>Removing a &kg; Patch</title>
  <para>
   Due to the way zypper operates, it is not sufficient to simply remove a
   &kg; patch with zypper. Rebuilding initrd and rebooting is required:
  </para>
  <procedure>
   <step>
   <para>
    First remove the patch itself using zypper:
   </para>
   <screen>
    zypper rm kgraft-patch-<replaceable>3_12_28-4-default</replaceable>
   </screen>
  </step>
  <step>
   <para>
    Then rebuild initrd:
   </para>
   <screen>
    mkinitrd
   </screen>
  </step>
  <step>
   <para>
    And reboot the machine.
   </para>
  </step>
  </procedure>
</sect1>
<sect1>
 <!--<title>Emergency Procedures And Experimental Functionality</title>
 <para>
  &kg; allows some experimental and emergency procedures.
 </para>
 <sect2>-->
   <title>Stuck Kernel Execution Threads</title>
   <para>
    Kernel threads need to be prepared to handle &kg;. Third-party software may
    not be completely ready for &kg; adoption and its kernel modules may spawn
    kernel execution threads. These threads will block the patching process
    indefinitely. As an emergency measure &kg; offers the possibility to force
    finishing of the patching process without waiting for all execution threads
    to cross the safety checkpoint. This can be achieved by writing
    <literal>0</literal> into
    <filename>/sys/kernel/kgraft/in_progress</filename>. Please consult SUSE
    Support before performing this procedure.
   </para>
   <!--</sect2>
   <sect2>
   <title>Live Patch Removal</title>
   <para>
    As an experimental feature &kg; supports patch removal. The low-level
    procedure is similar to patch installation. After writing
    <literal>1</literal> to
    <filename>/sys/kernel/kgraft/<replaceable>patch_name</replaceable>/revert</filename>
    the patch removal process starts. Again, processes need to leave kernel and
    kernel execution threads need to pass their checkpoints. After patching is
    finished the corresponding module can be removed from kernel. Please note
    that after performing this procedure support for the system cannot be
    claimed on SUSE.
   </para>
  </sect2>-->
</sect1>
<sect1>
 <title>The <command>kgr</command> Tool</title>
  <para>
   Several &kg; management tasks can be simplified
   with the <command>kgr</command> tool. The available commands are:
  </para>
  <variablelist>
   <varlistentry>
    <term><command>kgr status</command></term>
    <listitem>
     <para>
      Displays the overall status of &kg; patching (<literal>ready</literal> or
      <literal>in_progress</literal>).<!--It takes the information from
      <filename>/sys/kernel/kgraft/in_progress</filename>.-->
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>kgr patches</command></term>
    <listitem>
     <para>
      Displays the list of loaded &kg; patches.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>kgr blocking</command></term>
    <listitem>
     <para>
      Lists processes that are preventing &kg; patching from finishing. By
      default just the PIDs are listed. Specifying <option>-v</option> prints
      out command lines if available. Another <option>-v</option> displays
      also stack traces.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><command>kgr poke</command></term>
    <listitem>
     <para>
      Sends SIGSTOP and SIGCONT or other non-destructive signals
      to all processess that are blocking &kg; patching from finishing.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
  <para>
   For detailed information, see <command>man kgr</command>.
  </para>
</sect1>
<sect1>
 <title>Scope of &kg; Technology and SLE Live Patching</title>
 <para>
  &kg; is based on replacing functions.  Data structure alteration can be
  accomplished only indirectly with &kg;.  As a result, changes to kernel data
  structure require special care and, if the change is too large, rebooting
  might be required. &kg; also might not be able to handle situations where one
  compiler is used to compile the old kernel and another compiler is used for
  compiling the patch.
 </para>
 <para>
  Sending SIGSTOP and SIGCONT signals to processes in D process state
  (uninterruptible sleep) does not make them to cross the kernel/user space
  boundary and does not have the intended effect. Also, kernel threads by
  definition do not leave the kernel space and the &kg; patching must be
  supported at the kernel code level. Support for third-party modules
  that are spawning kernel threads is therefore limited.
 </para>
 <para>
  Fixes for CVSS (Common Vulnerability Scoring System) level 6+ vulnerabilities
  and bug fixes related to system stability or data corruption will be shipped
  in scope of SLE Live Patching.  It might not be possible to produce a live
  patch for all kinds of fixes fulfilling the above criteria.  SUSE reserves
  the right to skip fixes where production of a kernel live patch is unviable
  due to technical reasons.  For more information on CVSS, see <ulink
  url="http://nvd.nist.gov/cvss.cfm/" />.
 </para>
</sect1>
<sect1>
 <title>Interaction With the Support Processes</title>
 <para>
  In the course of resolving a technical difficulty with SUSE Support, you may
  receive so called Program Temporary Fix (PTF).  PTFs may be issued for
  various packages including those forming the base of SLE Live Patching.
 </para>
 <para>
  PTFs issued for the &kg; patch packages can be installed as usual and SUSE
  will make every effort so that the system in question does not have to be
  rebooted and future live updates apply cleanly.
 </para>
 <para>
  PTFs issued for the base kernel disrupt the live patching process.  First,
  installing the PTF kernel means a reboot as kernel cannot be replaced as
  whole at runtime.  Second, another reboot is needed to replace the PTF with
  regular maintenance update, for which the live patches are issued.
 </para>
 <para>
  PTFs for other packages in SLE Live Patching can be treated like regular PTFs
  with the usual guarantees.
 </para>
</sect1>
</article>
