<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd"
[
  <!ENTITY % NOVDOC.DEACTIVATE.IDREF "INCLUDE">
  <!ENTITY % entities SYSTEM "entity-decl.ent">
  %entities;
]>
<chapter id="cha.journalctl">
 <title><command>journalctl</command>: Query the &systemd; Journal</title>
 <para>
  When &systemd; replaced traditional init scripts in &sle; 12 (see
  <xref linkend="cha.systemd"/>, it introduced its own logging system called
  <emphasis>journal</emphasis>. There is no need to run a
  <systemitem>syslog</systemitem> based service anymore, as all system
  events are written in the journal.
 </para>
 <para>
  The journal itself is a system service managed by &systemd;. Its full name
  is <literal>systemd-journald.service</literal>. It collects and stores
  logging data by maintaining structured indexed journals based on logging
  information received from the kernel, from user processes, from standard
  input and error of system services. The
  <literal>systemd-journald.service</literal> service is on by default:
 </para>
<screen># systemctl status systemd-journald
systemd-journald.service - Journal Service
   Loaded: loaded (/usr/lib/systemd/system/systemd-journald.service; static)
   Active: active (running) since Mon 2014-05-26 08:36:59 EDT; 3 days ago
     Docs: man:systemd-journald.service(8)
           man:journald.conf(5)
 Main PID: 413 (systemd-journal)
   Status: "Processing requests..."
   CGroup: /system.slice/systemd-journald.service
           └─413 /usr/lib/systemd/systemd-journald
[...]</screen>
 <sect1 id="journalctl.persistent">
  <title>Making the Journal Persistent</title>

  <para>
   The journal stores log data in <filename>/run/log/journal/</filename> by
   default. Because the <filename>/run/</filename> directory is temporary by
   nature, log data is lost at reboot. To make the log data persistent, the
   directory <filename>/var/log/journal/</filename> must exist where the
   systemd-journald service stores its data. If it does not exist, create it
   and restart the systemd-journald service:
  </para>

<screen>mkdir /var/log/journal/ &amp;&amp; systemctl restart systemd-journald</screen>
 </sect1>
 <sect1 id="journalctl.switches">
  <title><command>journalctl</command> Useful Switches</title>

  <para>
   This section introduces several common useful options to enhance the
   default <command>journalctl</command> behavior. All switches are
   described in the <command>journalctl</command> manual page, <command>man
   1 journalctl</command>.
  </para>

  <tip>
   <para>
    To show all journal messages related to a specific executable, specify
    full path to the executable:
   </para>
<screen># journalctl /usr/lib/systemd/systemd</screen>
  </tip>

  <variablelist>
   <varlistentry>
    <term>-f</term>
    <listitem>
     <para>
      Shows only the most recent journal messages, and prints new log
      entries as they are added to the journal.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>-e</term>
    <listitem>
     <para>
      Prints the messages and jumps to the end of the journal, so that the
      latest entries are visible within the pager.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>-r</term>
    <listitem>
     <para>
      Prints the messages of the journal in a reverse order, so that the
      latest entries are listed first.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>-k</term>
    <listitem>
     <para>
      Show only kernel messages. This is equivalent to the field match
      <literal>_TRANSPORT=kernel</literal> (see
      <xref
  linkend="journalctl.filtering.fields"/>).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>-u</term>
    <listitem>
     <para>
      Show only messages for the specified &systemd; unit. This is
      equivalent to the field match
      <literal>_SYSTEMD_UNIT=<replaceable>UNIT</replaceable></literal> (see
      <xref
  linkend="journalctl.filtering.fields"/>).
     </para>
<screen># journalctl -u apache2
[...]
Jun 03 10:07:11 pinkiepie systemd[1]: Starting The Apache Webserver...
Jun 03 10:07:12 pinkiepie systemd[1]: Started The Apache Webserver.</screen>
    </listitem>
   </varlistentry>
  </variablelist>

  <para></para>
 </sect1>
 <sect1 id="journalctl.filtering">
  <title>Filtering the Journal Output</title>

  <para>
   When called without switches, <command>journalctl</command> shows the
   full content of the journal, the oldest entries listed first. The output
   can be filtered by specific switches and fields.
  </para>

  <sect2 id="journalctl.filtering.boot">
   <title>Filtering Based on a Boot Number</title>
   <para>
    <command>journalctl</command> can filter messages based on a specific
    system boot. To list all available boots, run
   </para>
<screen># journalctl --list-boots
-1 097ed2cd99124a2391d2cffab1b566f0 Mon 2014-05-26 08:36:56 EDT—Fri 2014-05-30 05:33:44 EDT
 0 156019a44a774a0bb0148a92df4af81b Fri 2014-05-30 05:34:09 EDT—Fri 2014-05-30 06:15:01 EDT</screen>
   <para>
    The first column lists the boot offset &mdash; 0 for the current boot,
    -1 for the previous, -2 for the second previous etc. The second column
    contains the boot ID, and then the limiting time stamps of the specific
    boot follow.
   </para>
   <para>
    Show all messages from the current boot:
   </para>
<screen># journalctl -b</screen>
   <para>
    If you need to see journal message from the previous boot, add an offset
    parameter. The following example outputs the previous boot messages:
   </para>
<screen># journalctl -b -1</screen>
   <para>
    Another way is to list boot messages based on the boot ID. For this
    purpose, use the _BOOT_ID field:
   </para>
<screen># journalctl _BOOT_ID=156019a44a774a0bb0148a92df4af81b</screen>
  </sect2>

  <sect2 id="journalctl.filtering.time">
   <title>Filtering Based on Time Interval</title>
   <para>
    You can filter the output of <command>journalctl</command> by specifying
    the starting and/or ending date. The date specification should be of the
    format "2014-06-30 9:17:16". If the time part is omitted, the midnight
    is assumed. If seconds are omitted, ":00" is assumed. If the date part
    is omitted, the current day is assumed. Instead of numeric expression,
    you can specify the keywords "yesterday", "today", or "tomorrow", which
    refer to the midnight of the day before the current day, the current
    day, or the day after the current day. If you specify "now", it refers
    to the current time. You can also specify relative times prefixed with
    <literal>-</literal> or <literal>+</literal>, referring to times before
    or after the current time.
   </para>
   <para>
    Show only new messages since now, and update the output continuously:
   </para>
<screen># journalctl --since "now" -f</screen>
   <para>
    Show all messages since last midnight till 3:20am:
   </para>
<screen># journalctl --since "today" --until "3:20"</screen>
  </sect2>

  <sect2 id="journalctl.filtering.fields">
   <title>Filtering Based on Fields</title>
   <para>
    You can filter the output of the journal by specific fields. The syntax
    of a field to be matched is <literal>FIELD_NAME=MATCHED_VALUE</literal>,
    such as <literal>_SYSTEMD_UNIT=httpd.service</literal>. You can specify
    multiple matches in a single query to filter the output messages event
    more. See <command>man 7 systemd.journal-fields</command> for a list of
    default fields.
   </para>
   <para>
    Show messages produced by a specific process ID:
   </para>
<screen># journalctl _PID=1039</screen>
   <para>
    Show messages belonging to a specific user ID:
   </para>
<screen># journalctl _UID=1000</screen>
   <para>
    Show messages from the kernel ring buffer (the same as
    <command>dmesg</command> produces):
   </para>
<screen># journalctl _TRANSPORT=kernel</screen>
   <para>
    Show messages from service's standard or error output:
   </para>
<screen># journalctl _TRANSPORT=stdout</screen>
   <para>
    Show messages produced by a specified service only:
   </para>
<screen># journalctl _SYSTEMD_UNIT=avahi-daemon.service</screen>
   <para>
    If two different fields are specified, only entries that match both
    expressions at the same time are shown:
   </para>
<screen># journalctl _SYSTEMD_UNIT=avahi-daemon.service _PID=1488</screen>
   <para>
    If two matches refer to the same field, all entries matching either
    expression are shown:
   </para>
<screen># journalctl _SYSTEMD_UNIT=avahi-daemon.service _SYSTEMD_UNIT=dbus.service</screen>
   <para>
    You can use the '+' separator to combine two expressions in a logical
    'OR'. The following example shows all messages from the Avahi service
    process with the process ID 1480 together with all messages from the
    D-Bus service:
   </para>
<screen># journalctl _SYSTEMD_UNIT=avahi-daemon.service _PID=1480 + _SYSTEMD_UNIT=dbus.service</screen>
  </sect2>
 </sect1>
 <sect1 id="journalctl.investigate">
  <title>Investigating &systemd; Errors</title>

  <para>
   This section introduces a simple example to illustrate how to find and
   fix the error reported by &systemd; during <command>apache2</command>
   start-up.
  </para>

  <procedure>
   <step>
    <para>
     Try to start the apache2 service:
    </para>
<screen># systemctl start apache2.service
Job for apache2.service failed. See 'systemctl status apache2.service' and 'journalctl -xn' for details.</screen>
   </step>
   <step>
    <para>
     Let us see what the service's status says:
    </para>
<screen># systemctl status apache2.service
apache2.service - The Apache Webserver
   Loaded: loaded (/usr/lib/systemd/system/apache2.service; disabled)
   Active: failed (Result: exit-code) since Tue 2014-06-03 11:08:13 CEST; 7min ago
  Process: 11026 ExecStop=/usr/sbin/start_apache2 -D SYSTEMD -DFOREGROUND \
           -k graceful-stop (code=exited, status=1/FAILURE)</screen>
    <para>
     The ID of the process causing the failure is 11026.
    </para>
   </step>
   <step>
    <para>
     Show the verbose version of messages related to process ID 11026:
    </para>
<screen># journalctl -o verbose _PID=11026
[...]
MESSAGE=AH00526: Syntax error on line 6 of /etc/apache2/default-server.conf:
[...]
MESSAGE=Invalid command 'DocumenttRoot', perhaps misspelled or defined by a module
[...]</screen>
   </step>
   <step>
    <para>
     Fix the typo inside
     <filename>/etc/apache2/default-server.conf</filename>, start the
     apache2 service, and print its status:
    </para>
<screen># systemctl start apache2 &amp;&amp; systemctl status apache2
apache2.service - The Apache Webserver
   Loaded: loaded (/usr/lib/systemd/system/apache2.service; disabled)
   Active: active (running) since Tue 2014-06-03 11:26:24 CEST; 4ms ago
  Process: 11026 ExecStop=/usr/sbin/start_apache2 -D SYSTEMD -DFOREGROUND 
           -k graceful-stop (code=exited, status=1/FAILURE)
 Main PID: 11263 (httpd2-prefork)
   Status: "Processing requests..."
   CGroup: /system.slice/apache2.service
           ├─11263 /usr/sbin/httpd2-prefork -f /etc/apache2/httpd.conf -D [...]
           ├─11280 /usr/sbin/httpd2-prefork -f /etc/apache2/httpd.conf -D [...]
           ├─11281 /usr/sbin/httpd2-prefork -f /etc/apache2/httpd.conf -D [...]
           ├─11282 /usr/sbin/httpd2-prefork -f /etc/apache2/httpd.conf -D [...]
           ├─11283 /usr/sbin/httpd2-prefork -f /etc/apache2/httpd.conf -D [...]
           └─11285 /usr/sbin/httpd2-prefork -f /etc/apache2/httpd.conf -D [...] 
</screen>
   </step>
  </procedure>
 </sect1>
</chapter>
