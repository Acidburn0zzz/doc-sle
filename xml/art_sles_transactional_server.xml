<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="urn:x-suse:xslt:profiling:docbook50-profile.xsl"
                 type="text/xml"
                 title="Profiling step"?>
<!DOCTYPE article
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>

<article xml:id="art.transactional" version="5.0" xml:lang="en"
 xmlns="http://docbook.org/ns/docbook"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink">
<?suse-quickstart color="suse"?>
 <title>Transactional Server Quick Start</title>
 <subtitle>&productname; &productnumber;</subtitle>
 <info>
  <productnumber>&productnumber;</productnumber><productname>&productname;</productname><date>
<?dbtimestamp format="B d, Y"?></date>
  <abstract>
   <para>
    &abstract_transactional_server;
   </para>
  </abstract>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:bugtracker></dm:bugtracker>
   <dm:translation>no</dm:translation>
  </dm:docmanager>
 </info>
<?suse-quickstart color="suse"?>

 <sect1 xml:id="sec.transactional-updates">
  <title>Transactional Updates</title>

  <para>
   For security and stability reasons, the operating system and application
   should always be up-to-date. While with a single machine you can keep the
   system up-to-date quite easily by running several commands, in a
   large-scale cluster the update process can become a real burden. Thus
   transactional automatic updates have been introduced. Transactional updates
   can be characterized as follows:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     They are atomic.
    </para>
   </listitem>
   <listitem>
    <para>
     They do not influence the running system.
    </para>
   </listitem>
   <listitem>
    <para>
     They can be rolled back.
    </para>
   </listitem>
   <listitem>
    <para>
     The system needs to be rebooted to activate the changes.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   Transactional updates are managed by the <command>transactional-update</command>
   script, which is called once a day. The script checks if any updates are
   available. If there are any updates to be applied, a new snapshot of the root
   file system is created in the background and is updated from the release
   channels. All updates released to this point are applied. The running
   file system/machine state is left untouched.
  </para>
  <para>
   The new snapshot, once completely updated, is then marked as active and will
   be used as the new default after the next reboot of the system.
  </para>
  <note>
   <title>Snapshot Activation</title>
   <para>
    For each "transaction" performed by <command>transactional-updates</command>
    a new snapshot is generated and requires a reboot to incorporate the
    changes. If another transaction is run before the reboot, only the latest
    snapshot is used and changes might be lost. If you perform manual updates
    or installation on your servers, please make sure to reboot after each
    transaction. <!-- FIXME Refer to:
     <xref linkend="sec.transactional-updates.installation.manual"/>. -->
   </para>
  </note>

  <!-- FIXME
  <para>
   &dashboard; will show a list of nodes that have new updates
   available for use. The cluster administrator then uses &dashboard; to reboot
   the nodes to the new snapshots to ensure the health of services and
   configuration. &dashboard; uses <command>salt</command> to safely disable
   services on the nodes, apply new snapshots, rewrite configurations and then
   bring the services and nodes back up.
  </para>
  -->
 </sect1>

 <sect1 xml:id="sec.transactional-updates.manage">
  <title>Installing and Managing Transactional Updates</title>

  <sect2 xml:id="sec.transactional-updates.command">
   <title>The <command>transactional-update</command> Command</title>
   <important>
    <title>Only use when requested by SUSE Support</title>
    <para>
     This reference for <command>transactional-update</command>
     should only be used when requested by SUSE Support. Updates are handled by
     an automated process and only require user interaction for rebooting of
     nodes.
    </para>
   </important>

   <para>
    The <command>transactional-update</command> command enables you to install or
    remove updates of your system in an atomic way. The updates are applied all
    or none of them if any package cannot be installed. Before the update is
    applied, a snapshot of the system is created in order to restore the
    previous state in case of a failure.
   </para>

   <para>
    If the current root file system is identical to the active root file system
    (after applying updates and reboot), run cleanup of all old snapshots:
   </para>
<screen>&prompt.root;<command>transactional-update cleanup</command></screen>
   <para>
    Other options of the command are the following:
   </para>
   <variablelist>
    <varlistentry>
     <term><literal>pkg in/install</literal></term>
     <listitem>
      <para>
       Installs individual packages from the available channels using the
       <command>zypper install</command> command. <!-- This command can also be used to
        install PTF RPM files. --> Please note that the changes to the base file system
       only become permanent after a reboot.
      </para>
<screen>&prompt.root;<command>transactional-update pkg install <replaceable>PACKAGE_NAME</replaceable></command></screen>
      <para>or</para>
<screen>&prompt.root;<command>transactional-update pkg install <replaceable>RPM1 RPM2</replaceable></command></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>pkg rm/remove</literal></term>
     <listitem>
      <para>
       Removes individual packages from the active snapshot using the
       <command>zypper remove</command> command. <!-- This command can also be used to
        remove PTF RPM files. --> Please note that the changes to the base file system
       only become permanent after a reboot.
      </para>
<screen>&prompt.root;<command>transactional-update pkg remove <replaceable>PACKAGE_NAME</replaceable></command></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>pkg up/update</literal></term>
     <listitem>
      <para>
       Updates individual packages from the active snapshot using the
       <command>zypper update</command> command. <!-- This command can also be used
        to update PTF RPM files. --> Please note that only packages that are part of
       the snapshot of the base file system can be updated and changes only
       become permanent after a reboot.
      </para>
      <screen>&prompt.root;<command>transactional-update pkg remove <replaceable>PACKAGE_NAME</replaceable></command></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>up/update</literal>
     </term>
     <listitem>
      <para>
       If there are new updates available, a new snapshot is created and
       <command>zypper up/update</command> is used to update the snapshot. The
       snapshot is activated afterwards and is used as the new root file system
       after reboot.
      </para>
<screen>&prompt.root;<command>transactional-update up</command></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>dup</literal>
     </term>
     <listitem>
      <para>
       If there are new updates available, a new snapshot is created and
       <command>zypper dup â€“no-allow-vendor-change</command> is used to
       update the snapshot. The snapshot is activated afterwards and is used as
       the new root file system after reboot.
      </para>
<screen>&prompt.root;<command>transactional-update dup</command></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>patch</literal>
     </term>
     <listitem>
      <para>
       If there are new updates available, a new snapshot is created and
       <command>zypper patch</command> is used to update the snapshot. The
       snapshot is activated afterwards and is used as the new root file system
       after reboot.
      </para>
<screen>&prompt.root;<command>transactional-update patch</command></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>rollback</literal>
     </term>
     <listitem>
      <para>
       The command sets the default sub volume. On systems with read-write file
       system <command>snapper rollback</command> is called. On a read-only
       file system and without any argument, the current system is set to a new
       default root file system. If you specify a number, that snapshot is used
       as the default root file system. On a read-only file system, no
       additional snapshots are created.
      </para>
<screen>&prompt.root;<command>transactional-update rollback <replaceable>SNAPSHOT_NUMBER</replaceable></command></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>grub.cfg</literal>
     </term>
     <listitem>
      <para>
       The command creates a new grub2 config. Sometimes it is necessary to
       adjust the boot configuration, e.g. by adding additional kernel parameters.
       This can be done by editing <replaceable>/etc/default/grub</replaceable>,
       calling <command>transactional-update grub.cfg</command> and then rebooting
       the machine to activate the change. Please note that without rebooting
       the machine, the new grub config will be overwritten with the default by
       any transactional-update that takes place.
      </para>
<screen>&prompt.root;<command>transactional-update grub.cfg</command></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>reboot</literal>
     </term>
     <listitem>
      <para>
       This parameter triggers a reboot after the action is completed.
      </para>
      <para>
       How the reboot is done depends on how <command>transactional-update</command>
       is configured. <!-- FIXME For cluster nodes this will set a Salt grain to show the
        updated node in &dashboard; as requiring reboot. -->
      </para>
<screen>&prompt.root;<command>transactional-update <replaceable>dup</replaceable> reboot</command></screen>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><literal>--help</literal>
     </term>
     <listitem>
      <para>
       The option outputs possible options and subcommands.
      </para>
<screen>&prompt.root;<command>transactional-update --help</command></screen>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec.transactional-updates.disable">
   <title>Disabling Transactional Updates</title>
   <para>
    Even though it is not recommended, you can disable transactional updates by
    issuing the command:
   </para>
<screen>&prompt.root;<command>systemctl --now disable transactional-update.timer</command></screen>
   <note>
    <title>Disabling transaction update timer is required during upgrade</title>
    <para>
     You must disable transactional updates during the upgrade procedure from
     one version of &productname; to the next.
    </para>
   </note>
  </sect2>

  <sect2 xml:id="sec.transactional-updates.installation">
   <title>Applying Updates</title>
   <para>
    It is paramount that you never "hard reboot" servers after
    transactional updates. This will omit reconfiguring services and applications
    and will leave nodes in unhealthy, if not unsusable, states.
   </para>

   <note>
    <title>General Notes to the Updates Installation</title>
    <para>
     Only packages that are part of the snapshot of the root file system can be
     updated. If packages contain files that are not part of the snapshot, the
     update could fail or break the system.
    </para>
    <para>
     RPMs that require a license to be accepted cannot be updated.
    </para>
   </note>

   <sect3 xml:id="sec.transactional-updates.installation.manual">
    <title>Applying Updates Manually</title>
    <para>
     You can use <command>transactional-update</command> to apply updates
     <!-- or install PTF files --> manually.
    </para>
<screen>&prompt.root;<command>transactional-update pkg install <replaceable>PACKAGE_NAME</replaceable> reboot</command></screen>
    <para>
     The server will reboot after the transactional-update has finished.
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="sec.transactional-updates.recovering">
   <title>Recovering From Failed Updates</title>
   <para>
    <!-- FIXME &dashboard; notifies you about failed updates.  -->
    If updates fail,
    there are several things that can be the cause. The following list
    provides an overview of things to check. <!--FIXME
     For general information about troubleshooting, read <xref
     linkend="sec.admin.troubleshooting.overview" />. -->
   </para>
   <warning>
    <title>Do Not Interfere with Transactional Updates</title>
    <para>
     Do not manually interfere with transactional updates. Do so only
     if you are requested to do so by &suse; support.
    </para>
    <para>
     For details, see <xref
      linkend="sec.transactional-updates.command" />.
    </para>
   </warning>
   <variablelist>
    <!-- FIXME
     <varlistentry>
     <term>Stopping Services and Reboot</term>
     <listitem>
     <para>
     &dashboard; uses &salt; to stop all services and reboot the node. Salt
     also takes care of adjusting configuration. Check the logs of
     the &salt; master and minions for error messages. For details,
     see <xref linkend="sec.admin.logging.salt.master" /> and <xref
     linkend="sec.admin.logging.salt.minion" />.
     </para>
     </listitem>
     </varlistentry>  -->
    <varlistentry>
     <term>Installing Updates</term>
     <listitem>
      <para>
       Updates are installed once a day but only applied after a reboot
       is manually triggered. If the installation of updates fails,
       <!-- FIXME &dashboard; shows the message <literal>Update Failed</literal> as the
        node's status. In this case, log in on the node and  --> check
       <filename>/var/log/transactional-update.log</filename> for
       problems.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Starting Services</term>
     <listitem>
      <para>
       Finally, all services of the server are being restarted. Look
       which services have failed by executing <command>systemctl
        list-units --failed</command>. Then check the logs of failed
       services.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>

 <xi:include href="common_copyright_quick.xml"/>
 <xi:include href="common_gfdl1.2_i.xml"/>
</article>
