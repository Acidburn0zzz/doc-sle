<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//Novell//DTD NovDoc XML V1.0//EN" "novdocx.dtd"
[
  <!ENTITY % NOVDOC.DEACTIVATE.IDREF "INCLUDE">
  <!ENTITY % entities SYSTEM "entity-decl.ent">
  %entities;
]>
<sect1 id="sec.basicnet.manconf">
 <title>Configuring a Network Connection Manually</title>

 <para>
  Manual configuration of the network software should be the last
  alternative. Using &yast; is recommended. However, this background
  information about the network configuration can also assist your work with
  &yast;.
 </para>

 <sect2>
  <!--
      initially based on
      /usr/share/doc/packages/wicked/README
  -->
  <title>The <command>wicked</command> Network Configuration</title>

  <para>
  The tool and library called <command>wicked</command> provides a new
  framework for network configuration.
  </para>

  <para>
   One of the challenges with traditional network interface management
   is that different layers of network management get jumbled together
   into one single script, or at most two different scripts, that
   interact with each other in a not-really-well-defined way, with side
   effects that are difficult to be aware of, obscure constraints and
   conventions, etc.  Several layers of special hacks for a variety of
   different scenarios increase the maintenance burden.  Address
   configuration protocols are being used that are implemented via
   daemons like dhcpcd, which interact rather poorly with the rest of
   the infrastructure. Funky interface naming schemes that require heavy
   udev support are introduced to achieve persistent identification of
   interfaces.
  </para>

  <para>
   The idea of wicked is to decompose the problem in several ways. None
   of them is entirely novel, but trying to put ideas from different
   projects together is hopefully going to create a better solution
   overall.
  </para>

  <para>
   One approach is to use a client/server model. This allows wicked to
   define standardized facilities for things like address configuration
   that are well integrated with the overall framework. For example,
   with address configuration, the administrator may request that an
   interface should be configured via dhcp or ipv4 zeroconf, and all the
   address configuration service does is obtain the lease from its
   server, and pass it on to the wicked server process, which installs
   the requested addresses and routes.
  </para>

  <para>
   The other approach to decomposing the problem is to enforce the
   layering aspect. For any type of network interface, it is possible to
   define a dbus service that configures the network interface's device
   layer&mdash;a VLAN, a bridge, a bonding, or a paravirtualized
   device.  Common functionality, such as address configuration, is
   implemented by joint services that are layered on top of these device
   specific services, without having to implement them specifically.
  </para>

  <para>
   The wicked framework implements these two aspects by using a variety
   of dbus services, which get attached to a network interface depending
   on its type.  Here is a rough overview of the current object
   hierarchy in wicked.
  </para>

  <para>
Each network interface is represented via a child object of
/org/opensuse/Network/Interfaces. The name of the child object is given
by its ifindex, so e.g. the loopback interface, which usually gets
ifindex 1, is /org/opensuse/Network/Interfaces/1, the first ethernet
interface registered is /org/opensuse/Network/Interfaces/2, etc.
  </para>
  <para>
Each network interface has a <quote>class</quote> associated with it,
which is used to select the dbus interfaces it supports. By default,
each network interface is of class <literal>netif</literal>, and wickedd
will automatically attach all interfaces compatible with this class. In
the current implementation, this includes the following interfaces:
  </para>

  <variablelist>
   <varlistentry>
    <term>org.opensuse.Network.Interface</term>
    <listitem>
     <para>
      Generic network interface functions, such as taking the link
      up or down, assigning an MTU, etc.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>org.opensuse.Network.Addrconf.ipv4.dhcp</term>
    <term>org.opensuse.Network.Addrconf.ipv6.dhcp</term>
    <term>org.opensuse.Network.Addrconf.ipv4.auto</term>
    <term>org.opensuse.Network.Addrconf.ipv6.auto</term>
    <listitem>
     <para>
      Address configuration services for DHCP, ipv6 autoconf, ipv4
      zeroconf, etc.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Beyond this, network interfaces may require or offer special
   configuration mechanisms. For example, for an Ethernet device, you
   may want to be able to control the link speed, offloading of
   checksumming, etc. To achieve this, Ethernet devices have a class of
   their own, called <literal>netif-ethernet</literal>, which is a
   subclass of <literal>netif</literal>. As a consequence, the dbus
   interfaces assigned to an Ethernet interface include all the services
   listed above, plus
   <systemitem>org.opensuse.Network.Ethernet</systemitem>, which is a
   service available only to objects belonging to the
   <literal>netif-ethernet</literal> class.
  </para>
  <para>
   Similarly, there exist classes for interface types like bridges,
   VLANs, bonds, or infinibands.
  </para>
  <para>
   How do you interact with an interface that needs to be created
   first&mdash;such as a VLAN, which is really a virtual network
   interface that sits on top of an Ethernet device.  For these, wicked
   defines factory interfaces, such as
   <systemitem>org.opensuse.Network.VLAN.Factory</systemitem>. Such a
   factory interface offers a single function that lets you create an
   interface of the requested type.  These factory interfaces are
   attched to the /org/opensuse/Network/Interfaces list node.
  </para>

  <sect3>
   <title>What's Currently Supported</title>

   <para>
    <command>wicked</command> currently supports:
   </para>

   <itemizedlist>
    <listitem>
     <para>
      Configuration file back-ends to parse SUSE and RedHat style
      <filename>/etc/sysconfig/network</filename> files. Since the
      development is on a SUSE installation, the former are probably
      significantly more stable than the RedHat ones.
     </para>
    </listitem>

    <listitem>
     <para>
      A configuration file back-end to represent network interface
      configuration in XML. The syntax evolved out of what netcf uses.
     </para>
    </listitem>
    <listitem>
     <para>
      Bring up and shutdown of <quote>normal</quote> network interfaces
      such as Ethernet or InfiniBand, as well as VLAN, bridges, and
      bonding devices.  Bridging and bonding may still have some issues.
     </para>
    </listitem>
    <listitem>
     <para>
      Wireless, not yet complete and limited to one network.
     </para>
    </listitem>
    <listitem>
     <para>
      A built-in DHCPv4 client and a built-in DHCPv6 client.
     </para>
    </listitem>
    <listitem>
     <para>
      There is some experimental code that should help to
      automatically bring up interfaces as soon as a link
      is detected.
     </para>
    </listitem>
    <listitem>
     <para>
      An XML reader/writer implementation, which is far from being fully
      standards conforming, but which has a small footprint and seems
      reasonably fast.  This comes along with a partial implementation of
      XPath 1.0, which lets you extract information from an XML interface
      description without having to do any XML parsing yourself.
     </para>
    </listitem>
   </itemizedlist>
  </sect3>
 </sect2>

 <xi:include
  xmlns:xi="http://www.w3.org/2001/XInclude" href="net_config_files.xml"/>

 <sect2 id="sec.basicnet.manconf.testing">
  <title>Testing the Configuration</title>
  <para>
   Before you write your configuration to the configuration files, you can
   test it. To set up a test configuration, use the <command>ip</command>
   command. To test the connection, use the <command>ping</command> command.
  </para>
  <para>
   The command <command>ip</command> changes the network configuration directly
   without saving it in the configuration file. Unless you enter your
   configuration in the correct configuration files, the changed network
   configuration is lost on reboot.
  </para>

   <note>
    <title><command>ifconfig</command> and <command>route</command> Are
    Obsolete</title>
    <para>
     The <command>ifconfig</command> and <command>route</command> tools
     are obsolete.  Use <command>ip</command> instead.
     <command>ifconfig</command>, for example, limits interface names to
     9 characters.
    </para>
   </note>

  <sect3 id="sec.basicnet.manconf.ip">
   <title>Configuring a Network Interface with <command>ip</command></title><indexterm>
   <primary>commands</primary>
   <secondary>ip</secondary></indexterm>
   <remark>
From: Marius Tomaschewski mt@suse.de>
Subject: Re: Manual Network Config
To: Karl Eichwalder ke@suse.de>
Date: Mon, 24 Aug 2009 14:21:44 +0200

Das ifconfig utility ist obsolete und unterstützt nur Interface-
Namen bis 9 Zeichen, z.B. "foo012345". Die restlichen Zeichen
werden abgeschnitten und nicht angezeigt.
Das "ip" utility unterstützt hingegen die derzeit volle Länge von
15 Zeichen, z.B. "foo012345678901".

Statt "ifconfig" sollte "ip addr" und "ip link" verwendet werden,
um routing zu konfigurieren, sollte nicht "route", sondern "ip route"
verwendendet werden.

...

IMO besser wäre es die Beispiel-Ausgaben von route und ifconfig zu
entfernen und stattdessen Beispiel-Ausgaben von:

"ip link show", "ip addr show",
"ip -4 route show", "ip -6 route show"
(und ggf. auch "ip rule show")

im "Configuring a Network Interface with ip" zu bringen. Eventuell
mit ein Paar Beispielen als eine Art Kurzanleitung, in etwa:

ip link set up dev eth0

ip addr add 192.168.0.100/24 dev eth0
ip addr add 2001:DB8:cafe::dead/64 dev eth0

ip route add 192.168.1.0/24 via 192.168.0.200 dev eth0
ip route add 2001:DB8:cafe:1::/64 via 2001:DB8:cafe::feed dev eth0

ip route add default via 192.168.0.254 dev eth0
ip route add default via 2001:DB8:cafe::beef dev eth0

ip addr show dev eth0
ip -4 route show # dev eth0
ip -6 route show # dev eth0

ip route del 192.168.1.0/24 via 192.168.0.200 dev eth0
ip route del 2001:DB8:cafe:1::/64 via 2001:DB8:cafe::feed dev eth0

ip route del default via 192.168.0.254 dev eth0
ip route del default via 2001:DB8:cafe::beef dev eth0

ip addr del 192.168.0.100/24 dev eth0
ip addr del 2001:DB8:cafe::dead/64 dev eth0

ip link set down dev eth0
</remark>
   <para>
    <command>ip</command> is a tool to show and configure network devices,
    routing, policy routing, and tunnels.
   </para>
   <para>
    <command>ip</command> is a very complex tool. Its common syntax is
    <command>ip</command>&nbsp;<option><replaceable>options</replaceable>
    <replaceable>object</replaceable>
    <replaceable>command</replaceable></option>. You can work with the
    following objects:
   </para>
   <variablelist>
    <varlistentry>
     <term>link</term>
     <listitem>
      <para>
       This object represents a network device.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>address</term>
     <listitem>
      <para>
       This object represents the IP address of device.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>neighbor</term>
     <listitem>
      <para>
       This object represents a ARP or NDISC cache entry.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>route</term>
     <listitem>
      <para>
       This object represents the routing table entry.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>rule</term>
     <listitem>
      <para>
       This object represents a rule in the routing policy database.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>maddress</term>
     <listitem>
      <para>
       This object represents a multicast address.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>mroute</term>
     <listitem>
      <para>
       This object represents a multicast routing cache entry.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>tunnel</term>
     <listitem>
      <para>
       This object represents a tunnel over IP.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    If no command is given, the default command is used (usually
    <command>list</command>).
   </para>
   <para>
    Change the state of a device with the command <command>ip link
    set</command>&nbsp;<option><replaceable>device_name</replaceable></option>&nbsp;<command><replaceable>command</replaceable></command>.
    For example, to deactivate device eth0, enter <command>ip link
    set</command> <option>eth0 down</option>. To activate it again, use
    <command>ip link set</command> <option>eth0 up</option>.
   </para>
   <para>
    After activating a device, you can configure it. To set the IP address,
    use <command>ip addr
    add</command>&nbsp;<option><replaceable>ip_address</replaceable> + dev
    <replaceable>device_name</replaceable></option>. For example, to set the
    address of the interface eth0 to 192.168.12.154/30 with standard
    broadcast (option <option>brd</option>), enter <command>ip
    addr</command>&nbsp;<option>add 192.168.12.154/30 brd + dev
    eth0</option>.
   </para>
   <para>
    To have a working connection, you must also configure the default
    gateway. To set a gateway for your system, enter <command>ip route
    add</command>&nbsp;<option>gateway_ip_address</option>. To translate one
    IP address to another, use <command>nat</command>: <command>ip route add
    nat</command>&nbsp;<option>ip_address</option>&nbsp;<command>via</command>&nbsp;<option>other_ip_address</option>.
   </para>
   <para>
    To display all devices, use <command>ip link ls</command>. To display
    the running interfaces only, use <command>ip link ls up</command>. To
    print interface statistics for a device, enter <command>ip -s link
    ls</command>&nbsp;<option>device_name</option>. To view addresses of
    your devices, enter <command>ip addr</command>. In the output of the
    <command>ip addr</command>, also find information about MAC addresses of
    your devices. To show all routes, use <command>ip route show</command>.
   </para>
   <para>
    For more information about using <command>ip</command>, enter
    <command>ip</command>&nbsp;<option>help</option> or see the
    <systemitem>ip(8)</systemitem> man page. The <option>help</option>
    option is also available for all <command>ip</command> subcommands. If,
    for example, you need help for
    <command>ip</command>&nbsp;<option>addr</option>, enter
    <command>ip</command>&nbsp;<option>addr help</option>. Find the
    <command>ip</command> manual in
    <filename>/usr/share/doc/packages/iproute2/ip-cref.pdf</filename>.
   </para>
  </sect3>
  <sect3 id="sec.basicnet.manconf.testingping">
   <title>Testing a Connection with ping</title><indexterm>
   <primary>commands</primary>
   <secondary>ping</secondary></indexterm><indexterm>
   <primary>ping</primary></indexterm>
   <para>
    The <command>ping</command> command is the standard tool for testing
    whether a TCP/IP connection works. It uses the ICMP protocol to send a
    small data packet, ECHO_REQUEST datagram, to the destination host,
    requesting an immediate reply. If this works, <command>ping</command>
    displays a message to that effect. This indicates that the network link
    is functioning.
   </para>
   <para>
    <command>ping</command> does more than only test the function of the
    connection between two computers: it also provides some basic
    information about the quality of the connection. In
    <xref
     linkend="ex.basicnet.manconf.ping"/>, you can see an example
    of the <command>ping</command> output. The second-to-last line contains
    information about the number of transmitted packets, packet loss, and
    total time of <command>ping</command> running.
   </para>
   <para>
    As the destination, you can use a hostname or IP address, for example,
    <command>ping</command>&nbsp;<option>&exampledomain;</option> or
    <command>ping</command>&nbsp;<option>&wwwip;</option>. The program sends
    packets until you press
    <keycombo><keycap>Ctrl</keycap><keycap>C</keycap></keycombo>.
   </para>
   <para>
    If you only need to check the functionality of the connection, you can
    limit the number of the packets with the <option>-c</option> option. For
    example to limit ping to three packets, enter
    <command>ping</command>&nbsp;<option>-c 3 &exampledomain;</option>.
   </para>
   <example id="ex.basicnet.manconf.ping">
    <title>Output of the Command ping</title>
<screen>ping -c 3 &exampledomain;
PING &exampledomain; (&wwwip;) 56(84) bytes of data.
64 bytes from &exampledomain; (&wwwip;): icmp_seq=1 ttl=49 time=188 ms
64 bytes from &exampledomain; (&wwwip;): icmp_seq=2 ttl=49 time=184 ms
64 bytes from &exampledomain; (&wwwip;): icmp_seq=3 ttl=49 time=183 ms
--- &exampledomain; ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2007ms
rtt min/avg/max/mdev = 183.417/185.447/188.259/2.052 ms</screen>
   </example>
   <para>
    The default interval between two packets is one second. To change the
    interval, ping provides the option <option>-i</option>. For example, to
    increase the ping interval to ten seconds, enter
    <command>ping</command>&nbsp;<option>-i 10 &exampledomain;</option>.
   </para>
   <para>
    In a system with multiple network devices, it is sometimes useful to
    send the ping through a specific interface address. To do so, use the
    <option>-I</option> option with the name of the selected device, for
    example, <command>ping</command>&nbsp;<option>-I wlan1
    &exampledomain;</option>.
   </para>
   <para>
    For more options and information about using ping, enter
    <command>ping</command>&nbsp;<option>-h</option> or see the
    <systemitem>ping (8)</systemitem> man page.
   </para>
   <tip>
    <title>Pinging IPv6 Addresses</title>
    <para>
     For IPv6 addresses use the <command>ping6</command> command. Note, to
     ping link-local addresses, you must specify the interface with
     <option>-I</option>. The following command works, if the address is
     reachable via <literal>eth1</literal>:
    </para>
<screen>ping6 -I eth1 fe80::117:21ff:feda:a425</screen>
   </tip>
  </sect3>
<!--
  <sect3 id="sec.basicnet.manconf.testingifconfig">
   <title>Configuring the Network with ifconfig</title><indexterm>
   <primary>commands</primary>
   <secondary>ifconfig</secondary></indexterm>
   <para>
    <command>ifconfig</command> is a network configuration tool.
   </para>
   <note>
    <title><command>ifconfig</command> and <command>ip</command></title>
    <para>
     The <command>ifconfig</command> tool is obsolete. Use
     <command>ip</command> instead. In contrast to <command>ip</command>,
     you can use <command>ifconfig</command> only for interface
     configuration. It limits interface names to 9 characters.
    </para>
   </note>
   <para>
    Without arguments, <command>ifconfig</command> displays the status of
    the currently active interfaces. As you can see in
    <xref
     linkend="ex.basicnet.manconf.ifconfig"/>,
    <command>ifconfig</command> has very well-arranged and detailed output.
    The output also contains information about the MAC address of your
    device (the value of <option>HWaddr</option>) in the first line.
   </para>
   <example id="ex.basicnet.manconf.ifconfig">
    <title>Output of the <command>ifconfig</command> Command</title>
<screen>eth0      Link encap:Ethernet  HWaddr 00:08:74:98:ED:51
          inet6 addr: fe80::208:74ff:fe98:ed51/64 Scope:Link
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:634735 errors:0 dropped:0 overruns:4 frame:0
          TX packets:154779 errors:0 dropped:0 overruns:0 carrier:1
          collisions:0 txqueuelen:1000
          RX bytes:162531992 (155.0 Mb)  TX bytes:49575995 (47.2 Mb)
          Interrupt:11 Base address:0xec80

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:8559 errors:0 dropped:0 overruns:0 frame:0
          TX packets:8559 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:533234 (520.7 Kb)  TX bytes:533234 (520.7 Kb)    

wlan1     Link encap:Ethernet  HWaddr 00:0E:2E:52:3B:1D
          inet addr:192.168.2.4  Bcast:192.168.2.255  Mask:255.255.255.0
          inet6 addr: fe80::20e:2eff:fe52:3b1d/64 Scope:Link
          UP BROADCAST NOTRAILERS RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:50828 errors:0 dropped:0 overruns:0 frame:0
          TX packets:43770 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:45978185 (43.8 Mb)  TX bytes:7526693 (7.1 MB)</screen>
   </example>
   <para>
    For more options and information about using
    <command>ifconfig</command>, enter
    <command>ifconfig</command>&nbsp;<option>-h</option> or see the
    <systemitem>ifconfig (8)</systemitem> man page.
   </para>
  </sect3>
  <sect3>
   <title>Configuring Routing with <command>route</command></title><indexterm>
   <primary>commands</primary>
   <secondary>route</secondary></indexterm>
   <para>
    <command>route</command> is a program for manipulating the IP routing
    table. You can use it to view your routing configuration and to add or
    remove routes.
   </para>
   <note>
    <title><command>route</command> and <command>ip</command></title>
    <para>
     The program <command>route</command> is obsolete. Use
     <command>ip</command> instead.
    </para>
   </note>
   <para>
    <command>route</command> is especially useful if you need quick and
    comprehensible information about your routing configuration to determine
    problems with routing. To view your current routing configuration, enter
    <command>route</command> <option>-n</option> as &rootuser;.
   </para>
   <example id="ex.basicnet.manconf.route">
    <title>Output of the <command>route <option>-n</option></command> Command</title>
<screen><?dbsuse-fo font-size="7pt"?>route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
10.20.0.0       *               255.255.248.0   U         0 0          0 eth0
link-local      *               255.255.0.0     U         0 0          0 eth0
loopback        *               255.0.0.0       U         0 0          0 lo
default         styx.exam.com   0.0.0.0         UG        0 0          0 eth0</screen>
   </example>
   <para>
    For more options and information about using route, enter
    <command>route</command>&nbsp;<option>-h</option> or see the
    <systemitem>route (8)</systemitem> man page.
   </para>
  </sect3>
-->
 </sect2>

 <sect2 id="sec.basicnet.manconf.scripts">
  <title>Start-Up Scripts</title><indexterm>
  <primary>scripts</primary>
  <secondary>init.d</secondary></indexterm>
  <para>
   Apart from the configuration files described above, there are also
   various scripts that load the network programs while the machine is
   booting. <remark>taroth 2014-02-13: not sure if the following is still
    correct, @file-maintainer: please check</remark>These are started as soon as the system is switched to the
   <literal>multi-user.target</literal>. Some of these scripts are
   described in <xref linkend="tab.netz.start.skripte"/>.
   <remark>taroth 2014-02-13: FIXME: SYSTEMD, WICKED</remark>
  </para>
  <table id="tab.netz.start.skripte">
<?dbsuse-latex tablehead="p{.4\linewidth}p{.55\linewidth}"?>
   <title>Some Start-Up Scripts for Network Programs</title>
   <tgroup cols="2" align="left">
    <tbody>
     <row>
      <entry>
       <para>
        <filename>/etc/init.d/network</filename>
        <!--ix-->
        <indexterm>
         <primary>scripts</primary>
         <secondary>init.d</secondary>
         <tertiary>network</tertiary>
        </indexterm>
       </para>
      </entry>
      <entry>
       <para>
        This script handles the configuration of the network interfaces. If
        the <command>network</command> service was not started, no network
        interfaces are implemented.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <filename>/etc/init.d/xinetd</filename> <indexterm>
        <primary>scripts</primary>
        <secondary>init.d</secondary>
        <tertiary>xinetd</tertiary>
        </indexterm>
       </para>
      </entry>
      <entry>
       <para>
        Starts xinetd. xinetd can be used to make server services available
        on the system. For example, it can start vsftpd whenever an FTP
        connection is initiated.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <filename>/etc/init.d/rpcbind</filename> <indexterm>
        <primary>scripts</primary>
        <secondary>init.d</secondary>
        <tertiary>rpcbind</tertiary>
        </indexterm>
       </para>
      </entry>
      <entry>
       <para>
        Starts the rpcbind utility that converts RPC program numbers to
        universal addresses. It is needed for RPC services, such as an NFS
        server.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <filename>/etc/init.d/nfsserver</filename> <indexterm>
        <primary>scripts</primary>
        <secondary>init.d</secondary>
        <tertiary>nfsserver</tertiary>
        </indexterm>
       </para>
      </entry>
      <entry>
       <para>
        Starts the NFS server.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <filename>/etc/init.d/postfix</filename> <indexterm>
        <primary>scripts</primary>
        <secondary>init.d</secondary>
        <tertiary>postfix</tertiary>
        </indexterm>
       </para>
      </entry>
      <entry>
       <para>
        Controls the postfix process.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <filename>/etc/init.d/ypserv</filename> <indexterm>
        <primary>scripts</primary>
        <secondary>init.d</secondary>
        <tertiary>ypserv</tertiary>
        </indexterm>
       </para>
      </entry>
      <entry>
       <para>
        Starts the NIS server.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        <filename>/etc/init.d/ypbind</filename> <indexterm>
        <primary>scripts</primary>
        <secondary>init.d</secondary>
        <tertiary>ypbind</tertiary>
        </indexterm>
       </para>
      </entry>
      <entry>
       <para>
        Starts the NIS client.
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect2>

</sect1>
